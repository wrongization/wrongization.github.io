<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>BUAA 2025编译实验 | wrongization</title><meta name="author" content="wrongization"><meta name="copyright" content="wrongization"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="BUAA 2025 编译器设计说明  实现词法分析 + 递归下降语法分析 + 语义分析（符号表与约束检查）+ LLVM IR 中间代码生成 + 中端优化 + Mips 目标代码生成  1. 总体目标 该项目实现一个精简 C &#x2F; SysY 风格语言的编译器五个核心阶段：  词法分析—— 将源代码字符流转换为 Token 序列，并进行最基本的错误分类。 语法分析—— 基于递归下降结构 + FIRST">
<meta property="og:type" content="article">
<meta property="og:title" content="BUAA 2025编译实验">
<meta property="og:url" content="https://wrongization.site/2026/01/10/compile.html">
<meta property="og:site_name" content="wrongization">
<meta property="og:description" content="BUAA 2025 编译器设计说明  实现词法分析 + 递归下降语法分析 + 语义分析（符号表与约束检查）+ LLVM IR 中间代码生成 + 中端优化 + Mips 目标代码生成  1. 总体目标 该项目实现一个精简 C &#x2F; SysY 风格语言的编译器五个核心阶段：  词法分析—— 将源代码字符流转换为 Token 序列，并进行最基本的错误分类。 语法分析—— 基于递归下降结构 + FIRST">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wrongization.site/img/cover/compile/compile.webp">
<meta property="article:published_time" content="2026-01-10T07:48:36.000Z">
<meta property="article:modified_time" content="2026-01-10T07:48:33.674Z">
<meta property="article:author" content="wrongization">
<meta property="article:tag" content="java">
<meta property="article:tag" content="编译">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wrongization.site/img/cover/compile/compile.webp"><link rel="shortcut icon" href="/img/logo.webp"><link rel="canonical" href="https://wrongization.site/2026/01/10/compile.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/%E5%8D%8E%E6%96%87%E4%B8%AD%E5%AE%8B%7CTitillium%20Web%7CPingFang%20SC%7CHiragino%20Sans%20GB%7CMicrosoft%20JhengHei%7CMicrosoft%20YaHeisans-serif" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":0},
  copy: {
    success: '成功复制~',
    error: '复制内容到了星之彼方',
    noSupport: '不支持的浏览器！'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":100,"languages":{"author":"作者: wrongization","link":"原文连接: ","source":"来源: https://wrongization.site","info":"复制和转载请标明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"你切换到了简体中文","cht_to_chs":"你切换到了繁体中文","day_to_night":"永远是深夜有多好。","night_to_day":"地球就是完美的观测特等席。","bgLight":"#7D26CD","bgDark":"#551A8B","position":"bottom-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '💡加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BUAA 2025编译实验',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2026-01-10 15:48:33'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="preconnect" href="https://lib.baomitu.com" crossorigin><link rel="preconnect" href="https://pic.imgdb.cn" crossorigin><link rel="stylesheet" href="/css/transpancy.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">🍵载入中...</div><!-- 新的精美加载条--><div class="progress-bar"><div class="progress-track"><div class="progress-fill"></div><div class="progress-glow"></div></div><div class="progress-text">正在向夜晚奔去...</div></div></div></div><script>(() => {
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const $progressBar = $loadingBox.querySelector('.progress-bar')
  const $progressFill = $loadingBox.querySelector('.progress-fill')
  const $progressText = $loadingBox.querySelector('.progress-text')
let determinateActivated = false
let currentPct = 0
// 进度模式：'proportional'（按资源完成比例推进）或 'ticker'（按时间匀速推进）
const PROGRESS_MODE = 'ticker'
// 统一节拍：让进度条均匀增长（不超过 MAX_TICK_PCT），真实完成时再跳到 100%
const MAX_TICK_PCT = 98 // 均匀增长的上限，避免未完成时到 100
const TICK_DURATION = 4000 // 从 0 均匀增长到 MAX_TICK_PCT 的目标时长(ms)
let tickerRAF = 0
let tickerStart = 0

  function setProgress(p) {
    const pct = Math.min(100, Math.max(0, p))
    const next = Math.max(currentPct, pct) // 只增不减，避免视觉回退
    if (!determinateActivated) {
      determinateActivated = true
      $progressBar.classList.add('determinate')
      $progressFill.style.animation = '' // stop indeterminate slide
    }
$progressBar.style.setProperty('--progress-pct', next + '%')
// 直接设置内联样式，确保视觉宽度与百分比一致（即使 CSS 尚未更新）
$progressFill.style.width = next + '%'
// 关闭动画与位移，避免出现仅一小段在滑动的视觉错觉
$progressFill.style.animation = 'none'
$progressFill.style.transform = 'none'
    if ($progressText) $progressText.setAttribute('data-percent', next.toFixed(0) + '%')
    currentPct = next
  }

  function stopTicker() {
    if (tickerRAF) {
      cancelAnimationFrame(tickerRAF)
      tickerRAF = 0
    }
  }

function startTicker() {
    stopTicker()
    tickerStart = performance.now()
    const tick = (now) => {
      if ($loadingBox.classList.contains('loaded')) return // 已结束不再推进
      const elapsed = now - tickerStart
      const target = Math.min(MAX_TICK_PCT, (elapsed / TICK_DURATION) * MAX_TICK_PCT)
      setProgress(target)
      tickerRAF = requestAnimationFrame(tick)
    }
    tickerRAF = requestAnimationFrame(tick)
  }

  // 小工具：为 Promise 加超时上限，避免个别资源阻塞
  function withTimeout(promise, ms) {
    let timer
    const timeout = new Promise(resolve => { timer = setTimeout(resolve, ms) })
    return Promise.race([
      promise.finally(() => clearTimeout(timer)),
      timeout
    ])
  }

function calcAssets() {
    // 只跟踪“首屏/非懒加载”的关键图片 + 字体(限时) + DOM 就绪 + (load 限时)
    const allImgs = Array.from(document.images || [])
    const vh = window.innerHeight || 800
    const isNearViewport = img => {
      const rect = img.getBoundingClientRect ? img.getBoundingClientRect() : null
      return rect ? rect.top < vh * 1.2 : true
    }
    const isLazy = img => (
      img.loading === 'lazy' || img.getAttribute('data-src') || img.getAttribute('data-original')
    )
    const trackedImgs = allImgs.filter(img => {
      // 非懒加载直接跟踪；懒加载只跟踪在视口附近的
      if (isLazy(img)) return isNearViewport(img)
      return true
    })

    const trackers = []

    // 图片：逐个计数，并给每张上限 3.5s，避免单张图卡住
    trackedImgs.forEach(img => {
      const p = new Promise(resolve => {
        if (img.complete && img.naturalWidth) return resolve()
        const done = () => resolve()
        const timer = setTimeout(done, 3500)
        img.addEventListener('load', () => { clearTimeout(timer); done() }, { once: true })
        img.addEventListener('error', () => { clearTimeout(timer); done() }, { once: true })
      })
      trackers.push(p)
    })

    // 字体：整体一次，并设置 1.8s 上限
    if (document.fonts && document.fonts.ready) {
      trackers.push(withTimeout(document.fonts.ready.catch(() => {}), 1800))
    }

    // DOM 就绪：尽早推进
    const domReady = new Promise(resolve => {
      if (document.readyState === 'interactive' || document.readyState === 'complete') return resolve()
      document.addEventListener('DOMContentLoaded', () => resolve(), { once: true })
    })
    trackers.push(domReady)

    // window load：作为“保险”，但最多等 2.5s
    const loadCapped = new Promise(resolve => {
      if (document.readyState === 'complete') return resolve()
      const t = setTimeout(resolve, 2500)
      window.addEventListener('load', () => { clearTimeout(t); resolve() }, { once: true })
    })
    trackers.push(loadCapped)

    let finished = 0
    const total = trackers.length || 1
    const onOneDone = () => {
      finished++
      if (PROGRESS_MODE === 'proportional') {
        // 直接按比例更新，保持严格对应
        const pct = (finished / total) * 100
        setProgress(pct)
      }
      if (finished >= total) {
        // 完成：先瞬到上限（如未到），短暂停留后再到 100 并打开
        stopTicker()
        const needPadToCap = currentPct < 100
        if (needPadToCap) setProgress(100)
        const finish = () => { preloader.endLoading() }
        if (needPadToCap) setTimeout(finish, 100)
        else finish()
      }
    }
    trackers.forEach(p => p.then(onOneDone))

    // 兜底：强制结束，避免极端情况下长时间遮挡（到点即刻收起）
    setTimeout(() => {
      if (!$loadingBox.classList.contains('loaded')) {
        stopTicker()
        setProgress(100)
        preloader.endLoading()
      }
    }, 7000)
  }

  const preloader = {
    endLoading: () => {
stopTicker()
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  function start() {
    preloader.initLoading()
    determinateActivated = false
currentPct = 0
    setProgress(0)
    if (PROGRESS_MODE === 'ticker') startTicker()
    requestAnimationFrame(calcAssets)
  }

  start()

  // 可选 PJAX 支持：若站点启用 pjax，重新触发加载条
  // 适配常见 pjax / instant.page / swup 事件，可按需精简
  const pjaxEvents = ['pjax:send','pjax:complete','swup:animationInStart','swup:contentReplaced']
  pjaxEvents.forEach(ev => {
    document.addEventListener(ev, e => {
      if (ev.includes('send') || ev.includes('animationIn')) {
        start()
      } else if (ev.includes('complete') || ev.includes('contentReplaced')) {
        // 重新统计新页面资源
        requestAnimationFrame(calcAssets)
      }
    })
  })
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo.webp" onerror="onerror=null;src='/img/gif404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">类别</div><div class="length-num">30</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-images"></i><span> 图库</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-paint-brush"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-camera"></i><span> 摄影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 推荐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movie/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><!-- 添加 data-effect 以支持顶图特效切换 (sunset | rainy | sunny | sunrise)--><!-- 默认 rainy，可通过主题配置 theme.header_effect_default 覆盖--><header class="post-bg fixed" id="page-header" style="background-image: url('/img/cover/compile/compile.webp')" data-effect="rainy"><nav id="nav"><span id="blog-info"><a href="/" title="wrongization"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo.webp"/><span class="site-name">wrongization</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-images"></i><span> 图库</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-paint-brush"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-camera"></i><span> 摄影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 推荐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movie/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">BUAA 2025编译实验</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">创建</span><time class="post-meta-date-created" datetime="2026-01-10T07:48:36.000Z" title="创建 2026-01-10 15:48:36">2026-01-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新</span><time class="post-meta-date-updated" datetime="2026-01-10T07:48:33.674Z" title="更新 2026-01-10 15:48:33">2026-01-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E8%AF%91/">编译</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数统计:</span><span class="word-count">14.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时间:</span><span>55分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="post-series"><h3>编译-系列：</h3><li><a class="title" href="/2026/01/10/compile.html" title="BUAA 2025编译实验">BUAA 2025编译实验</a></li></div><article class="post-content" id="article-container"><h1>BUAA 2025 编译器设计说明</h1>
<blockquote>
<p>实现词法分析 + 递归下降语法分析 + 语义分析（符号表与约束检查）+ LLVM IR 中间代码生成 + 中端优化 + Mips 目标代码生成</p>
</blockquote>
<h2 id="1-总体目标">1. 总体目标</h2>
<p>该项目实现一个精简 C / SysY 风格语言的<strong>编译器</strong>五个核心阶段：</p>
<ol>
<li>词法分析—— 将源代码字符流转换为 Token 序列，并进行最基本的错误分类。</li>
<li>语法分析—— 基于递归下降结构 + FIRST 集判断与有限回溯，将 Token 序列还原为抽象/混合语法树（目前更接近具体语法树 ）。</li>
<li>语义分析—— 基于作用域栈构建符号表，完成重定义、未定义引用、函数调用实参与形参检查、左值可赋性、return 规则、循环控制语句使用、printf 占位符数量等检查。</li>
<li>中间代码生成和优化—— 遍历语法树生成 LLVM IR 中间代码，包含基本块管理、寄存器分配、控制流处理、优化 pass 框架等。</li>
<li>目标代码生成—— 将 LLVM IR 转换为 MIPS 汇编代码。</li>
</ol>
<p>设计强调：</p>
<ul>
<li>模块化：<code>frontend</code> 下按阶段与节点类型分类，<code>midend</code> 下按 IR 生成与优化分类。</li>
<li>可扩展：BNF 规则集中于 <code>frontend/BNF/Gram.java</code>，IR 生成逻辑集中于 <code>midend/LLVMGenerator.java</code>，优化 pass 可插拔式添加，Mips 生成逻辑集中于 <code>backend/MIPSGenerator.java</code>。</li>
<li>错误恢复策略：仅在缺失分号、右括号、右中括号时报错，节点仍然添加并继续。</li>
<li>输出：词法结果 <code>lexer.txt</code>，语法树 + 规约序列 <code>parser.txt</code>，符号表 <code>symbol.txt</code>，所有阶段合并错误 <code>error.txt</code>，LLVM IR 代码 <code>llvm_ir.txt</code>，Mips 目标代码 <code>mips.txt</code>。</li>
<li>近期修复：后端在 <code>icmp</code>/<code>zext</code> 的布尔结果生成后立即落栈并标记为 clean，防止寄存器复用导致布尔打印/逻辑判断拿到旧值（触发场景：开启 Mem2Reg + Phi 展开 + StrengthReduction + GVN + DCE 时的 <code>not</code> 输出偏差）。</li>
</ul>
<h2 id="2-目录结构与职责">2. 目录结构与职责</h2>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">README.md                   // 本文档</span><br><span class="line">config.json                 // 配置</span><br><span class="line">Compiler.java               // 统一驱动：文件读取、注释预处理、阶段调度、结果落盘</span><br><span class="line">frontend/</span><br><span class="line">  Lexer.java                // 词法分析器（行扫描 + 正则分类 + 手写多字符运算符匹配）</span><br><span class="line">  Parser.java               // 语法分析入口（调用 Gram.CompUnit）</span><br><span class="line">  Symboler.java             // 语义分析入口（调用 Sym.CompUnit）</span><br><span class="line">  BNF/</span><br><span class="line">    Gram.java               // 所有产生式 + 递归下降实现 + FIRST 集登记</span><br><span class="line">    Sym.java                // 语义遍历：依据语法节点逐步建表与检查</span><br><span class="line">  nodes/</span><br><span class="line">    Node.java               // 抽象语法树节点基类（含输出 DFS）</span><br><span class="line">    Symbol.java             // 符号条目：变量/数组/常量/函数/符号表（含形参列表与作用域号）</span><br><span class="line">    Token.java              // 终结符 Token 封装</span><br><span class="line">    Unit.java               // 非终结符节点</span><br><span class="line">  result/</span><br><span class="line">    Result.java             // 阶段结果与错误集合基类</span><br><span class="line">    Scope.java              // 作用域记录：符号表节点、编号、类型、返回态</span><br><span class="line">    SymbolResult.java       // 语义阶段结果（符号表、作用域栈、检查接口）</span><br><span class="line">    TokenResult.java        // 词法阶段结果</span><br><span class="line">    UnitResult.java         // 语法阶段结果</span><br><span class="line">midend/</span><br><span class="line">  LLVMGenerator.java        // LLVM IR 生成主逻辑（遍历 AST + 指令构建）</span><br><span class="line">  ir/</span><br><span class="line">    ModuleBuilder.java      // 全局声明管理（全局变量、常量数组、字符串池）</span><br><span class="line">    FunctionContext.java    // 函数局部上下文（寄存器/标签计数、符号表）</span><br><span class="line">    Addr.java               // 地址/变量抽象</span><br><span class="line">    Value.java              // 值抽象（立即数/寄存器/全局变量）</span><br><span class="line">    LocalVar.java           // 局部变量/数组元素的地址与类型信息</span><br><span class="line">    StringConst.java        // 字符串常量封装</span><br><span class="line">  opt/</span><br><span class="line">    PassManager.java        // 优化 pass 管理器</span><br><span class="line">    OptimizationPass.java   // 优化 pass 接口（含 normalizeIndent 辅助方法）</span><br><span class="line">    OptimizationOptions.java // 优化选项配置</span><br><span class="line">    SSATransformPass.java   // SSA 转换（前端已完成，NO-OP）</span><br><span class="line">    Mem2RegPass.java        // 内存到寄存器提升（含 Phi 节点最小化）</span><br><span class="line">    PhiEliminationPass.java // Phi 节点删除（基于内存展开，必要时为使用块注入 reload 保证支配关系）</span><br><span class="line">    InstSimplifyPass.java   // 指令简化（zext 消除、常量折叠、代数简化；分支改写默认关闭以避免后端分支语义歧义）</span><br><span class="line">    FunctionInliningPass.java // 函数内联（小函数、递归检测、寄存器重命名）</span><br><span class="line">    LoopUnrollingPass.java  // 循环展开（完全/部分展开、智能决策）</span><br><span class="line">    ConstantPropagationPass.java // 常量传播（含数组常量传播）</span><br><span class="line">    StrengthReductionPass.java // 强度削减（乘除法→移位、小常数优化）</span><br><span class="line">    GVNPass.java            // 全局值编号（公共子表达式消除、重复 load 消除）</span><br><span class="line">    CFGSimplifyPass.java    // 控制流简化（常量分支折叠、死块删除）</span><br><span class="line">    TailCallOptimizationPass.java // 尾递归优化（尾调用→循环转换</span><br><span class="line">    DeadCodeEliminationPass.java // 死代码删除</span><br><span class="line">backend/</span><br><span class="line">  MIPSGenerator.java        // MIPS 目标代码生成</span><br><span class="line">  MIPSContext.java          // MIPS 生成上下文</span><br></pre></td></tr></table></figure>
<h2 id="3-词法分析设计">3. 词法分析设计</h2>
<h3 id="3-1-处理流程">3.1 处理流程</h3>
<ol>
<li><code>Compiler</code> 逐行读取 <code>testfile.txt</code>，按照行存入 <code>lines</code> 列表，然后调用 <code>preprocess</code> 进行注释预处理，存入 <code>preprocessedLines</code> 列表。</li>
<li><code>Lexer</code> 调用<code>analyze</code> 方法，传入 <code>preprocessedLines</code> 列表。</li>
<li>注释预处理后的非空行传递给 <code>analyzeLine</code> 方法：
<ul>
<li>基于<strong>单次线性扫描</strong>：
<ul>
<li>维护临时 <code>StringBuilder token</code> 累积潜在标识符 / 数字 / 字符串常量。</li>
<li>每遇到：
<ul>
<li>双字符候选（如 <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code>, <code>&amp;&amp;</code>, <code>||</code>）优先匹配。</li>
<li>单字符分隔符 / 运算符立即截断并归约前一 Token。</li>
<li><code>&quot;</code> 进入字符串提取直到下一个 <code>&quot;</code>（无转义支持，缺失闭合时报错）。</li>
</ul>
</li>
<li><strong>行尾人为补一空格触发最后一个 token flush。</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-2-关键数据结构">3.2 关键数据结构</h3>
<ul>
<li>关键字映射 <code>KEYWORDS</code>：<code>Map&lt;String, TokenType&gt;</code></li>
<li>符号映射 <code>SYMBOLS</code>：包含单双字符运算符，提前硬编码。</li>
<li>Token 分类优先级：符号 &gt; 关键字 &gt; 字符串常量 &gt; 标识符 &gt; 整数常量 &gt; 错误。</li>
</ul>
<h3 id="3-3-正则与最小化判断">3.3 正则与最小化判断</h3>
<table>
<thead>
<tr>
<th>类别</th>
<th>正则 / 判定</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>标识符</td>
<td><code>[a-zA-Z_][a-zA-Z0-9_]*</code></td>
<td>兼容下划线开头</td>
</tr>
<tr>
<td>整数常量</td>
<td><code>\d+</code></td>
<td>仅十进制</td>
</tr>
<tr>
<td>字符串常量</td>
<td><code>&quot;[^\&quot;]*&quot;</code></td>
<td>不含内部引号（无转义机制）</td>
</tr>
</tbody>
</table>
<h3 id="3-4-错误处理策略">3.4 错误处理策略</h3>
<ul>
<li>非法字符输出报错，不产生“a”错误，修改<code>Success</code>为false。</li>
<li>针对孤立 <code>|</code> 或 <code>&amp;</code> 容错：<code>token</code> 仍然映射为 <code>OR</code> 或 <code>AND</code>（降低级联错误），输出错误信息“a”</li>
</ul>
<h3 id="3-5-设计亮点">3.5 设计亮点</h3>
<ul>
<li>使用函数 <code>handleToken()</code> 统一 flush 逻辑，避免重复 if 栈。</li>
<li>双字符运算符通过前瞻 <code>line.substring(i,i+2)</code> 零回溯匹配。</li>
<li>将错误与成功 token 均写入序列，以定位后续语法文法更多错误。</li>
</ul>
<h2 id="4-语法分析设计">4. 语法分析设计</h2>
<h3 id="4-1-方法论">4.1 方法论</h3>
<p>采用<strong>手写递归下降解析器</strong>，不借助自动生成器，优势：</p>
<ul>
<li>代码即文法：<code>Gram</code> 内部类一一对应产生式，易维护。</li>
<li>通过 FIRST 集 + 适度向前看消除二义性（函数定义 vs 变量声明、Unary/Call 分支、Stmt的EXP和Lval等）。</li>
<li>运行期构建语法树节点 <code>Unit</code>（非终结符）与 <code>Token</code>（终结符）混合结构，可直接用于后继语义/IR。</li>
</ul>
<h3 id="4-2-文法（简化-BNF-摘要）">4.2 文法（简化 BNF 摘要）</h3>
<p>（与代码保持一致，省略空产生式 <code>[]</code> 与重复 <code>&#123;&#125;</code> 的括号说明）</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">CompUnit      -&gt; &#123;Decl&#125; &#123;FuncDef&#125; MainFuncDef</span><br><span class="line">Decl          -&gt; ConstDecl | VarDecl</span><br><span class="line">ConstDecl     -&gt; &#x27;const&#x27; BType ConstDef &#123;&#x27;,&#x27; ConstDef&#125; &#x27;;&#x27;</span><br><span class="line">ConstDef      -&gt; Ident &#123;&#x27;[&#x27; ConstExp &#x27;]&#x27;&#125; &#x27;=&#x27; ConstInitVal</span><br><span class="line">ConstInitVal  -&gt; ConstExp | &#x27;&#123;&#x27; [ ConstExp &#123;&#x27;,&#x27; ConstExp&#125; ] &#x27;&#125;&#x27;</span><br><span class="line">BType         -&gt; &#x27;int&#x27;</span><br><span class="line">VarDecl       -&gt; [&#x27;static&#x27;] BType VarDef &#123;&#x27;,&#x27; VarDef&#125; &#x27;;&#x27;</span><br><span class="line">VarDef        -&gt; Ident &#123;&#x27;[&#x27; ConstExp &#x27;]&#x27;&#125; [ &#x27;=&#x27; InitVal ]</span><br><span class="line">InitVal       -&gt; Exp | &#x27;&#123;&#x27; [ Exp &#123;&#x27;,&#x27; Exp&#125; ] &#x27;&#125;&#x27;</span><br><span class="line">FuncType      -&gt; &#x27;void&#x27; | &#x27;int&#x27;</span><br><span class="line">FuncDef       -&gt; FuncType Ident &#x27;(&#x27; [FuncFParams] &#x27;)&#x27; Block</span><br><span class="line">MainFuncDef   -&gt; &#x27;int&#x27; &#x27;main&#x27; &#x27;(&#x27; &#x27;)&#x27; Block</span><br><span class="line">FuncFParams   -&gt; FuncFParam &#123;&#x27;,&#x27; FuncFParam&#125;</span><br><span class="line">FuncFParam    -&gt; BType Ident [&#x27;[&#x27; &#x27;]&#x27;]</span><br><span class="line">Block         -&gt; &#x27;&#123;&#x27; &#123; BlockItem &#125; &#x27;&#125;&#x27;</span><br><span class="line">BlockItem     -&gt; Decl | Stmt</span><br><span class="line">Stmt          -&gt; LVal &#x27;=&#x27; Exp &#x27;;&#x27;</span><br><span class="line">               | [Exp] &#x27;;&#x27;</span><br><span class="line">               | Block</span><br><span class="line">               | &#x27;if&#x27; &#x27;(&#x27; Cond &#x27;)&#x27; Stmt [&#x27;else&#x27; Stmt]</span><br><span class="line">               | &#x27;for&#x27; &#x27;(&#x27; [ForStmt] &#x27;;&#x27; [Cond] &#x27;;&#x27; [ForStmt] &#x27;)&#x27; Stmt</span><br><span class="line">               | &#x27;break&#x27; &#x27;;&#x27;</span><br><span class="line">               | &#x27;continue&#x27; &#x27;;&#x27;</span><br><span class="line">               | &#x27;return&#x27; [Exp] &#x27;;&#x27;</span><br><span class="line">               | &#x27;printf&#x27; &#x27;(&#x27; STRCON &#123;&#x27;,&#x27; Exp&#125; &#x27;)&#x27; &#x27;;&#x27;</span><br><span class="line">ForStmt       -&gt; LVal &#x27;=&#x27; Exp &#123; &#x27;,&#x27; LVal &#x27;=&#x27; Exp &#125;</span><br><span class="line">Exp           -&gt; AddExp</span><br><span class="line">Cond          -&gt; LOrExp</span><br><span class="line">LVal          -&gt; Ident &#123;&#x27;[&#x27; Exp &#x27;]&#x27;&#125;</span><br><span class="line">PrimaryExp    -&gt; &#x27;(&#x27; Exp &#x27;)&#x27; | LVal | Number</span><br><span class="line">Number        -&gt; INTCON</span><br><span class="line">UnaryExp      -&gt; PrimaryExp | Ident &#x27;(&#x27; [FuncRParams] &#x27;)&#x27; | UnaryOp UnaryExp</span><br><span class="line">UnaryOp       -&gt; &#x27;+&#x27; | &#x27;-&#x27; | &#x27;!&#x27;</span><br><span class="line">FuncRParams   -&gt; Exp &#123;&#x27;,&#x27; Exp&#125;</span><br><span class="line">MulExp        -&gt; UnaryExp &#123; (&#x27;*&#x27;|&#x27;/&#x27;|&#x27;%&#x27;) UnaryExp &#125;</span><br><span class="line">AddExp        -&gt; MulExp &#123; (&#x27;+&#x27;|&#x27;-&#x27;) MulExp &#125;</span><br><span class="line">RelExp        -&gt; AddExp &#123; (&#x27;<span class="attribute">&lt;&#x27; | &#x27;&gt;</span>&#x27; | &#x27;<span class="attribute">&lt;=&#x27; | &#x27;&gt;</span>=&#x27;) AddExp &#125;</span><br><span class="line">EqExp         -&gt; RelExp &#123; (&#x27;==&#x27; | &#x27;!=&#x27;) RelExp &#125;</span><br><span class="line">LAndExp       -&gt; EqExp &#123; &#x27;&amp;&amp;&#x27; EqExp &#125;</span><br><span class="line">LOrExp        -&gt; LAndExp &#123; &#x27;||&#x27; LAndExp &#125;</span><br><span class="line">ConstExp      -&gt; AddExp</span><br></pre></td></tr></table></figure>
<h3 id="4-3-关键消除二义性-左递归策略">4.3 关键消除二义性/左递归策略</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>冲突来源</th>
<th>解决手法</th>
<th>代码位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>Decl vs FuncDef vs MainFuncDef</td>
<td><code>int Ident ( ...</code> 既可能是函数（主函数）定义也可能是变量声明（数组）</td>
<td>预读 <code>INTTK IDENFR LPARENT</code> 判定</td>
<td><code>CompUnit.parse</code> while 循环条件内部</td>
</tr>
<tr>
<td>赋值语句 vs 表达式语句</td>
<td><code>Ident ...</code> 开头既可能是 LVal 或普通EXP</td>
<td>调用 <code>LVal.parse_back</code> 预读判断后跟 <code>ASSIGN</code></td>
<td><code>Stmt.parse</code> 第一分支</td>
</tr>
<tr>
<td>UnaryExp 分支冲突</td>
<td><code>Ident</code> 既可能是函数调用也可能是 LVal/PrimaryExp</td>
<td>向前看后一个 token 是否 <code>LPARENT</code></td>
<td><code>UnaryExp.parse</code></td>
</tr>
<tr>
<td>左递归（E -&gt; E op T）</td>
<td>直接写递归会无限</td>
<td>改写为迭代收集，再“回填”成左结合树</td>
<td><code>MulExp</code>, <code>AddExp</code>, <code>RelExp</code>, <code>EqExp</code>, <code>LAndExp</code>, <code>LOrExp</code></td>
</tr>
</tbody>
</table>
<h4 id="左结合树重构技巧">左结合树重构技巧</h4>
<p>解析形如 <code>A op B op C op D</code>：</p>
<ol>
<li>线性收集为节点序列 <code>[A, op1, B, op2, C, op3, D]</code>。</li>
<li>逆向折叠构造：最右 <code>(C op3 D)</code> 作为最里层，逐步外包，保证遍历输出次序仍符合递归下降生成顺序。代码以 <code>for (int i = children.size()-1; i&gt;0; i-=2)</code> 反向建新父节点。</li>
</ol>
<h3 id="4-4-FIRST-集与可选-重复部分">4.4 FIRST 集与可选/重复部分</h3>
<ul>
<li>每个内部类维护 <code>FirstToken</code> 静态列表；在构造块中组合所依赖子产生式 FIRST 集。</li>
<li>可选部分 <code>[X]</code> 统一通过 <code>if (X.FirstToken.contains(currentType))</code> 判定。</li>
<li>重复部分 <code>&#123;X&#125;</code> 使用 while，并在体内推进 <code>pos</code>。</li>
</ul>
<h3 id="4-5-错误检测与恢复">4.5 错误检测与恢复</h3>
<p><code>expectToken(result, parent, tokens, pos, expectedType)</code>：</p>
<ul>
<li>若匹配失败：
<ul>
<li>针对 <code>;</code>，<code>)</code>,<code>]</code>追加错误</li>
<li>其他情况控制台输出dubug信息</li>
<li>不回退、不跳过（当前实现直接返回原 pos，后续可能导致级联，但保留树结构）。</li>
</ul>
</li>
<li>成功：将终结符挂入父节点。</li>
</ul>
<p><strong>对于报错i，即缺少<code>;</code>，对于<code>stmt-&gt;[exp] ';' </code>,在块的最后可能缺失语句，这时仍然需要报错缺少i,需要将<code>&#125;</code>纳入<code>lval</code>和<code>exp</code>的判断分支，然后进行预读回溯。</strong></p>
<p><code>LVal.parse_back</code></p>
<p>左值和表达式的预读判断。</p>
<p>不实际移动pos，虚假处理一个<code>lval</code>，但是注意<strong>最后一个“]”不能改变temp的success判断，只做pos移动</strong>，同时语法部分success的修改只发生在除去<code>）]&#125;</code>以外的情况下，如果缺少右括号不修改success。</p>
<h3 id="4-6-语法树输出策略">4.6 语法树输出策略</h3>
<ul>
<li><code>Node.output()</code> 对非终结符采用<strong>后序遍历</strong>（children 先输出到AST列表，再输出自身 <code>&lt;Type&gt;</code>，对于题目要求的<code>&lt;BlockItem&gt;</code>, <code>&lt;Decl&gt;</code>, <code>&lt;BType&gt;</code>实际添加节点，但是输出时删去，最后统一输出AST列表到文件）。</li>
</ul>
<h3 id="4-7-设计亮点总结">4.7 设计亮点总结</h3>
<table>
<thead>
<tr>
<th>点</th>
<th>价值</th>
</tr>
</thead>
<tbody>
<tr>
<td>统一 <code>Unit</code> 节点枚举</td>
<td>避免字符串判断，提升类型安全与可维护性</td>
</tr>
<tr>
<td>局部 FIRST 集缓存</td>
<td>减少重复分支判断逻辑，可做 LL(1) 验证扩展</td>
</tr>
<tr>
<td><code>lval</code>预读函数 <code>parse_back</code></td>
<td>将模糊前缀解析与正式构建分离，降低副作用</td>
</tr>
<tr>
<td>左结合逆向折叠算法</td>
<td>保持语义正确 + 最小化栈深度</td>
</tr>
<tr>
<td>错误类型内聚 <code>expectToken</code></td>
<td>单点维护错误策略，方便扩展更多错误码</td>
</tr>
</tbody>
</table>
<h3 id="4-8-FIRST集列表">4.8 FIRST集列表</h3>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">CompUnit: [CONSTTK, INTTK, STATICTK]</span><br><span class="line">Decl: [CONSTTK, INTTK, STATICTK]</span><br><span class="line">ConstDecl: [CONSTTK]</span><br><span class="line">ConstDef: [CONSTTK]</span><br><span class="line">ConstInitVal: [LPARENT, IDENFR, INTCON, IDENFR, PLUS, MINU, NOT, LBRACE]</span><br><span class="line">BType: [INTTK]</span><br><span class="line">VarDecl: [INTTK, STATICTK]</span><br><span class="line">VarDef: [IDENFR]</span><br><span class="line">InitVal: [LPARENT, IDENFR, INTCON, IDENFR, PLUS, MINU, NOT, LBRACE]</span><br><span class="line">FuncDef: [VOIDTK, INTTK]</span><br><span class="line">FuncType: [VOIDTK, INTTK]</span><br><span class="line">MainFuncDef: [INTTK]</span><br><span class="line">FuncFParams: [INTTK]</span><br><span class="line">FuncFParam: [INTTK]</span><br><span class="line">Block: [LBRACE]</span><br><span class="line">BlockItem: [CONSTTK, INTTK, STATICTK, IDENFR, LPARENT, IDENFR, INTCON, IDENFR, PLUS, MINU, NOT, SEMICN, LBRACE, IFTK, FORTK, BREAKTK, CONTINUETK, RETURNTK, PRINTFTK]</span><br><span class="line">Stmt: [IDENFR, LPARENT, IDENFR, INTCON, IDENFR, PLUS, MINU, NOT, SEMICN, LBRACE, IFTK, FORTK, BREAKTK, CONTINUETK, RETURNTK, PRINTFTK]</span><br><span class="line">ForStmt: [IDENFR]</span><br><span class="line">Exp: [LPARENT, IDENFR, INTCON, IDENFR, PLUS, MINU, NOT]</span><br><span class="line">Cond: [LPARENT, IDENFR, INTCON, IDENFR, PLUS, MINU, NOT]</span><br><span class="line">LVal: [IDENFR]</span><br><span class="line">PrimaryExp: [LPARENT, IDENFR, INTCON]</span><br><span class="line">Number: [INTCON]</span><br><span class="line">UnaryExp: [LPARENT, IDENFR, INTCON, IDENFR, PLUS, MINU, NOT]</span><br><span class="line">UnaryOp: [PLUS, MINU, NOT]</span><br><span class="line">FuncRParams: [LPARENT, IDENFR, INTCON, IDENFR, PLUS, MINU, NOT]</span><br><span class="line">MulExp: [LPARENT, IDENFR, INTCON, IDENFR, PLUS, MINU, NOT]</span><br><span class="line">AddExp: [LPARENT, IDENFR, INTCON, IDENFR, PLUS, MINU, NOT]</span><br><span class="line">RelExp: [LPARENT, IDENFR, INTCON, IDENFR, PLUS, MINU, NOT]</span><br><span class="line">EqExp: [LPARENT, IDENFR, INTCON, IDENFR, PLUS, MINU, NOT]</span><br><span class="line">LAndExp: [LPARENT, IDENFR, INTCON, IDENFR, PLUS, MINU, NOT]</span><br><span class="line">LOrExp: [LPARENT, IDENFR, INTCON, IDENFR, PLUS, MINU, NOT]</span><br><span class="line">ConstExp: [LPARENT, IDENFR, INTCON, IDENFR, PLUS, MINU, NOT]</span><br></pre></td></tr></table></figure>
<h2 id="5-语义分析设计">5. 语义分析设计</h2>
<h3 id="5-1-核心思路与职责">5.1 核心思路与职责</h3>
<ul>
<li>采用“按语法树语义遍历”的方式：<code>Symboler.analyze(root, result)</code> 入口调用 <code>Sym.CompUnit.symbolize</code>，以与语法产生式一致的内部类分发，逐节点处理。</li>
<li>建立“作用域栈”（<code>SymbolResult.scopes</code>），每进入 Block/函数体等新作用域时 <code>pushnumber(type)</code>，离开时 <code>popnumber()</code>；每个作用域拥有一个符号表节点（<code>Symbol(SymbolTable)</code>），编号自增并记录在符号条目的 <code>number</code> 字段；记录深度<code>depth</code>，以便中间代码生成使用。</li>
<li><code>symbolize()</code>每层传入上一层<code>type</code>，<code>block</code>进入后读取，然后重置为普通类型。<code>for</code>对于<code>stmt</code>传入for类型，用于判断单句for语句。</li>
<li>符号输出为“扁平列表”<code>symbols</code>，但作用域查询基于栈顶至全局逐层查找，支持同名屏蔽。</li>
<li>语义检查与建表同步进行，尽量沿语法树遍历顺序定位并报告错误。</li>
</ul>
<h3 id="5-2-符号模型与条目类型">5.2 符号模型与条目类型</h3>
<p><code>frontend/nodes/Symbol.SymbolType</code> 支持：</p>
<ul>
<li>变量：<code>Int</code>、<code>StaticInt</code></li>
<li>数组：<code>IntArray</code>、<code>StaticIntArray</code></li>
<li>常量：<code>ConstInt</code>、<code>ConstIntArray</code></li>
<li>函数：<code>IntFunc</code>、<code>VoidFunc</code>（含形参列表 <code>parameterlist</code>）</li>
<li>特殊：<code>SymbolTable</code>（仅作为作用域内的符号表根节点）</li>
</ul>
<p>函数符号的形参列表在函数体建表时补全：先插入函数符号（参数列表为空），解析 <code>FuncFParams</code> 到临时 <code>SymbolResult</code>，<strong>注意此时也有可能报错重定义，但是报错存储在temp，需要之后读取存入真正的result</strong>，进入函数体 <code>Block</code> 前将形参迁入当前作用域并回填到函数符号的 <code>parameterlist</code>。</p>
<p>内建函数：在编译单元开始时注入 <code>getint</code>（<code>IntFunc</code>，无参数），用于通过语义检查；落盘到 <code>symbol.txt</code> 前会移除该内建条目（仅用于检查与查询）。</p>
<h3 id="5-3-作用域类型与返回值约束">5.3 作用域类型与返回值约束</h3>
<p><code>Scopetype</code>：<code>RETURNFUNC</code>、<code>NORETURNFUNC</code>、<code>NORMALBLOCK</code>、<code>PARAMS</code>、<code>FOR</code>。</p>
<ul>
<li>仅当作用域类型为 <code>RETURNFUNC</code> 时，进入作用域时将 <code>returned=false</code>，return时将<strong>当前作用域</strong>修改为<code>true</code>（文法要求只判断结尾处的return）</li>
<li>如果向上层找，<code>inreturn()==false</code>且return后方有数值，报错不匹配return（错误码f）。</li>
<li><code>block</code>结束时候判断是否为<code>true</code>，离开作用域若仍为 <code>false</code>，报告缺失 return（错误码 g），报错行号定位在函数 <code>&#125;</code> 行。</li>
<li><code>MainFuncDef</code> 按返回值函数处理（<code>RETURNFUNC</code>），要求显式 <code>return</code>。</li>
<li><code>FOR</code> 用于标识循环体，配合 <code>infor()</code>和上一层传入的type（单语句for） 检查 <code>break/continue</code> 的合法性。</li>
</ul>
<h3 id="5-4-主要检查点（与触发位置）">5.4 主要检查点（与触发位置）</h3>
<ul>
<li>重定义（b）：在当前作用域 <code>localhasSymbol</code> 命中即报错。位置：<code>ConstDef</code>、<code>VarDef</code>、<code>FuncDef</code>、<code>FuncFParam</code>。</li>
<li>未定义/非法引用（c）：
<ul>
<li>标识符用作变量/数组：<code>LVal</code> 未在任一可见作用域出现<code>globalhasSymbol</code>未命中则报错。</li>
<li>标识符用作函数调用：不存在或<strong>非函数同名符号</strong>时报错。</li>
</ul>
</li>
<li>函数调用实参与形参：
<ul>
<li>数量不匹配（d）。</li>
<li>维度不匹配（e）：仅区分“标量 vs 数组”。当前实现通过实参与形参的“是否数组”判定；实参侧以<strong>表达式原样字符串</strong>去符号表查询是否为数组，未做常量折叠/类型推导。</li>
</ul>
</li>
<li>return 规则：
<ul>
<li>无返回值函数含有带返回值的 <code>return</code>（f）。</li>
<li>有返回值函数末尾缺少 <code>return</code>（g）。</li>
</ul>
</li>
<li>左值可赋性（h）：赋值语句左侧为**常量、函数名或仅为数组名（缺少下标）**时非法。</li>
<li>循环控制语句位置（m）：不在 <code>for</code> 语义区域内使用 <code>break/continue</code>。</li>
<li>printf 校验（l）：格式串中 <code>%d</code> 的数量须与后随表达式个数一致，仅统计“%d”模式，不解析其他转义。</li>
</ul>
<p>限制与约定：</p>
<ul>
<li>数组&quot;大小与初始化值&quot;的表达式未进行常量折叠与语义校验,当前仅登记名称与数组属性。</li>
<li>实参数组判断采用表达式字符串级别的符号表查询,未进行更深的类型推断。</li>
<li><strong>static 变量作用域处理</strong>：<code>static</code> 关键字修饰的变量在语义分析阶段仍按局部变量处理,登记在当前作用域的符号表中,类型标记为 <code>StaticInt</code> / <code>StaticIntArray</code>。与普通局部变量的区别在中间代码生成阶段体现：static 变量会被提升为全局变量(但仅在声明函数内可见),生成全局声明而非栈上 <code>alloca</code>,从而保证生命周期跨函数调用。</li>
</ul>
<h3 id="5-5-符号表输出">5.5 符号表输出</h3>
<p><code>symbol.txt</code> 输出经作用域编号排序后的条目，格式为：<code>&lt;scopeNumber&gt; &lt;name&gt; &lt;SymbolType&gt;</code>。内建 <code>getint</code> 不输出。该文件用于辅助评测与调试。</p>
<h3 id="5-6错误与日志">5.6错误与日志</h3>
<table>
<thead>
<tr>
<th>错误码</th>
<th>触发条件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>词法非法 token</td>
<td>含未识别字符（如孤立 |、&amp; 等）</td>
</tr>
<tr>
<td>i</td>
<td>缺少 <code>;</code></td>
<td>语句/声明结束分号缺失（语法阶段）</td>
</tr>
<tr>
<td>j</td>
<td>缺少 <code>)</code></td>
<td>括号未闭合（语法阶段）</td>
</tr>
<tr>
<td>k</td>
<td>缺少 <code>]</code></td>
<td>数组下标/形参方括号未闭合（语法阶段）</td>
</tr>
<tr>
<td>b</td>
<td>符号重定义</td>
<td>同一作用域内重复定义变量/常量/函数（语义阶段）</td>
</tr>
<tr>
<td>c</td>
<td>未定义引用/非法使用</td>
<td>变量或函数未定义，或以非函数实体进行函数调用（语义阶段）</td>
</tr>
<tr>
<td>d</td>
<td>实参与形参数量不匹配</td>
<td>函数调用（语义阶段）</td>
</tr>
<tr>
<td>e</td>
<td>实参与形参类型不匹配</td>
<td>仅区分数组与标量（语义阶段）</td>
</tr>
<tr>
<td>f</td>
<td>无返回值函数带返回值</td>
<td><code>return exp;</code> 出现在 <code>void</code> 函数内（语义阶段）</td>
</tr>
<tr>
<td>g</td>
<td>有返回值函数缺少 return</td>
<td>函数末尾未返回（报 <code>&#125;</code> 行）（语义阶段）</td>
</tr>
<tr>
<td>h</td>
<td>非法左值赋值</td>
<td>对常量/函数名/数组名（无下标）赋值（语义阶段）</td>
</tr>
<tr>
<td>l</td>
<td>printf 占位符不匹配</td>
<td><code>%d</code> 数量与实参个数不一致（语义阶段）</td>
</tr>
<tr>
<td>m</td>
<td>非循环内使用 break/continue</td>
<td>语句出现在非 <code>for</code> 区域（语义阶段）</td>
</tr>
<tr>
<td>(预留)</td>
<td>其他可扩展</td>
<td>如缺少 <code>&#125;</code>、函数重定义细化等</td>
</tr>
</tbody>
</table>
<h2 id="6-中间代码生成设计">6. 中间代码生成设计</h2>
<h3 id="6-1-核心思路与架构">6.1 核心思路与架构</h3>
<p>中间代码生成阶段将语法树转换为 LLVM IR（中间表示），采用以下设计原则：</p>
<ul>
<li><strong>单遍遍历</strong>：基于语法树结构，对每个节点递归生成对应的 IR 指令</li>
<li><strong>静态单赋值（SSA）形式</strong>：每个虚拟寄存器只赋值一次，通过寄存器计数器自动生成唯一标识</li>
<li><strong>基本块管理</strong>：自动插入标签、维护控制流跳转</li>
<li><strong>类型系统</strong>：支持 i32（整数）、i32*（指针/数组）、i8*（字符串指针）</li>
<li><strong>优化框架</strong>：可插拔式 pass 管理器，支持后续添加各类优化</li>
</ul>
<h3 id="6-2-关键组件">6.2 关键组件</h3>
<h4 id="6-2-1-ModuleBuilder（全局管理器）">6.2.1 ModuleBuilder（全局管理器）</h4>
<p>职责：</p>
<ul>
<li>管理全局变量声明（<code>globalDecls</code>）</li>
<li>字符串常量池（<code>stringPool</code> + <code>stringCount</code>）</li>
<li>常量数组与初始化值映射（<code>constArrays</code>、<code>constArraysInit</code>）</li>
<li>函数形参信息缓存（<code>funcParamIsArray</code>、<code>funcParamNumber</code>）</li>
<li>函数返回值类型映射（<code>funcRet</code>）</li>
</ul>
<p>关键方法：</p>
<ul>
<li><code>addGlobalDecl(String)</code>：添加全局声明</li>
<li><code>addStringConst(String)</code>：注册字符串常量并返回全局变量名（如 <code>@.str.0</code>）</li>
<li><code>addConstArray(String, ArrayList&lt;Integer&gt;)</code>：登记常量数组</li>
<li><code>build()</code>：输出完整的 LLVM IR 模块（声明 + 全局变量 + 函数定义）</li>
</ul>
<p>附加说明（局部 const 缓存）：</p>
<ul>
<li>为了支持函数内部常量（const 标量与 const 数组）在常量表达式中的求值，生成器在生成局部 const 定义时会把其常量值写入 <code>ModuleBuilder</code> 的常量映射；键使用 <code>funcName::varName</code> 的复合形式，以区分同名的全局与局部常量。这样 <code>evalConst</code> 在遇到 LVal 时可以优先查找当前函数作用域的常量缓存，再回退到模块级全局常量缓存。该策略为低侵入实现，后续可考虑把常量缓存改为显式的 per-function map 以提升可维护性。</li>
</ul>
<h4 id="6-2-2-FunctionContext（函数上下文）">6.2.2 FunctionContext（函数上下文）</h4>
<p>职责：</p>
<ul>
<li>虚拟寄存器计数（<code>regCounter</code>）：生成 <code>%1, %2, ...</code></li>
<li>基本块标签计数（<code>labelCounter</code>）：生成 <code>label1, label2, ...</code></li>
<li>局部变量表（<code>localVars</code>）：变量名 → <code>LocalVar</code>（地址、类型、维度）</li>
<li>作用域深度管理（<code>depth</code>）</li>
</ul>
<p>关键方法：</p>
<ul>
<li><code>nextReg()</code>：分配新寄存器</li>
<li><code>nextLabel()</code>：分配新标签</li>
<li><code>addLocalVar(String, Addr, ...)</code>：登记局部变量</li>
<li><code>lookupVar(String)</code>：查找变量（支持作用域穿透）</li>
<li><code>enterScope()</code> / <code>exitScope()</code>：维护作用域深度</li>
</ul>
<h4 id="6-2-3-LLVMGenerator（IR-生成核心）">6.2.3 LLVMGenerator（IR 生成核心）</h4>
<p>主要职责与设计要点：</p>
<ul>
<li>目标：从前端语法树生成语义正确、风格统一且可被后端优化器（text-based passes）消费的 LLVM IR 文本。</li>
<li>原则：生成的 IR 要满足下列条件：
<ul>
<li>可读性：每个基本块、寄存器、全局常量都有可预测命名（便于调试与测试）。</li>
<li>可重构性：避免把语义嵌入注释或不可解析的格式，保证优化 pass 能通过文本正则或行级解析可靠工作。</li>
<li>语义等价：生成的指令序列在语义上等价于源程序（符合 SysY/C 子集语义），并遵守左到右求值约定（printf 等处明确实现）。</li>
</ul>
</li>
</ul>
<p>主要流程（简要）：</p>
<ol>
<li>预处理：收集全局/函数签名、常量数组与字符串常量表（ModuleBuilder）。</li>
<li>生成运行时声明：输出 <code>declare</code>/内建 runtime（<code>getint</code>, <code>putint</code>, <code>putch</code>, <code>putstr</code> 等）。</li>
<li>遍历 AST：按产生式分发到对应 <code>gen*</code> 方法（<code>genCompUnit</code>, <code>genFuncDef</code>, <code>genBlock</code>, <code>genStmt</code>, <code>genExp</code> 等）。</li>
<li>每个函数：创建 <code>FunctionContext</code>（寄存器/标签计数器、局部变量表），生成入口块、指令与控制流，确保终结 <code>ret</code>。</li>
<li>可选：将生成的 IR 传入 <code>PassManager.runAll(...)</code> 进行一轮或多轮优化。</li>
<li>输出：将最终 IR 写入 <code>llvm_ir.txt</code>（并可同时输出模块级别声明文件）。</li>
</ol>
<p>关键生成接口（示例）：</p>
<ul>
<li><code>String genCompUnit(Unit root)</code>：生成整个模块的 IR 文本。</li>
<li><code>String genFuncDef(Unit funcNode, FunctionContext ctx)</code>：在给定上下文中生成函数体。</li>
<li><code>Value genExp(Unit expNode, FunctionContext ctx)</code>：生成表达式并返回 Value 抽象（立即数/寄存器/全局）。</li>
<li><code>Addr genLVal(Unit lvalNode, FunctionContext ctx)</code>：返回可以被 <code>load</code>/<code>store</code> 操作使用的地址表达式。</li>
</ul>
<p>实现细节与注意点：</p>
<ul>
<li>寄存器与标签命名使用 <code>FunctionContext.nextReg()</code> / <code>nextLabel()</code> 保证在一个函数内唯一，并在模块级通过函数名前缀避免冲突。</li>
<li>对于 <code>printf</code>/格式化输出，采用两阶段生成：先按左到右顺序评估所有实参并保存临时寄存器，然后按格式串生成 <code>putstr</code>/<code>putint</code> 调用，保证有副作用的表达式按语言语义执行顺序。</li>
<li>对数组、getelementptr 的生成要保留一致的格式（例如 <code>getelementptr [N x i32], [N x i32]* @arr, i32 0, i32 %idx</code>），便于后续 pass 的正则匹配与模式识别。</li>
<li>在生成 <code>alloca</code>/<code>load</code>/<code>store</code> 时保留标准缩进与行分割，优化 pass 依赖这些约定进行文本级分析（本项目中的多数学流变换基于文本匹配实现）。</li>
</ul>
<p>局部 const 求值实现说明：</p>
<ul>
<li>在函数生成阶段，<code>LLVMGenerator</code> 会维护一个 <code>CURRENT_FUNCTION</code>（类型为 <code>FunctionContext</code>）用于标记正在处理的函数；当进入函数生成时设置该变量，离开时清除。</li>
<li>当遇到局部 const 定义（<code>genConstDef</code>）时，生成器会把常量值（标量或数组）写入 <code>ModuleBuilder</code> 的常量映射，并以 <code>funcName::varName</code> 作为键；同时仍会在函数上下文中为变量分配 <code>alloca</code> 并存储初始值。</li>
<li>常量求值函数 <code>evalConst</code> 在解析到 <code>LVal</code>（PrimaryExp -&gt; LVal）时会：
<ol>
<li>若存在 <code>CURRENT_FUNCTION</code>，先以 <code>funcName::name</code> 的键查找 <code>ModuleBuilder</code> 的局部常量缓存；</li>
<li>若未命中，再查找模块级的全局常量缓存（<code>constInts</code> / <code>constArrays</code>）；</li>
<li>若均未命中或索引越界，则返回空或按防御策略返回 0。</li>
</ol>
</li>
</ul>
<p>该实现可让局部 const 与全局 const 在常量表达式求值中正确区分并优先使用局部定义，修复了先前只能读取模块级常量的问题。</p>
<p>示例（函数片段）：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@add_one</span>(<span class="type">i32</span> <span class="variable">%x</span>) &#123;</span><br><span class="line"><span class="symbol">entry:</span></span><br><span class="line">  <span class="variable">%r</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%x</span><span class="punctuation">,</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="variable">%r</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可扩展点：</p>
<ul>
<li>如果将来迁移到更结构化的 IR（AST/IR 对象图），LLVMGenerator 的 <code>gen*</code> 接口可直接输出中间数据结构，再由一个独立的后端序列化为文本；当前实现优先保证可调试性与 pass 的可工作性。</li>
</ul>
<h3 id="6-3-关键技术点">6.3 关键技术点</h3>
<h4 id="6-3-1-变量与数组处理">6.3.1 变量与数组处理</h4>
<ul>
<li>
<p><strong>全局变量</strong>：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">@globalVar</span> <span class="operator">=</span> dso_local <span class="keyword">global</span> <span class="type">i32</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>全局数组</strong>：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">@arr</span> <span class="operator">=</span> dso_local <span class="keyword">global</span> [<span class="number">10</span> <span class="keyword">x</span> <span class="type">i32</span>] <span class="keyword">zeroinitializer</span></span><br></pre></td></tr></table></figure>
<p>初始化值存储在 <code>constArraysInit</code>，生成时展开</p>
</li>
<li>
<p><strong>局部变量</strong>：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%initVal</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>局部数组</strong>：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">alloca</span> [<span class="number">10</span> <span class="keyword">x</span> <span class="type">i32</span>]</span><br></pre></td></tr></table></figure>
<p>通过 <code>getelementptr</code> 计算元素地址</p>
</li>
<li>
<p><strong>static 变量处理</strong>：</p>
<ul>
<li>
<p><strong>语义分析阶段</strong>：标记为 <code>StaticInt</code> / <code>StaticIntArray</code>，登记在函数作用域符号表中</p>
</li>
<li>
<p><strong>IR 生成阶段</strong>：提升为全局变量，生命周期跨函数调用</p>
</li>
<li>
<p><strong>命名策略</strong>：使用函数名前缀避免冲突，如 <code>@func_staticVar</code></p>
</li>
<li>
<p><strong>可见性</strong>：仅在声明函数内可访问（通过符号表查询控制）</p>
</li>
<li>
<p><strong>初始化</strong>：</p>
<ul>
<li>全局声明时初始化（与普通全局变量相同）</li>
<li>初始化表达式在首次执行时计算（需要运行时初始化则使用构造函数或入口块）</li>
</ul>
</li>
<li>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    counter++;</span><br><span class="line">    putint(counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的 IR：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">@func_counter</span> <span class="operator">=</span> dso_local <span class="keyword">global</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="type">void</span> <span class="title">@func</span>() &#123;</span><br><span class="line"><span class="symbol">entry:</span></span><br><span class="line">  <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="title">@func_counter</span></span><br><span class="line">  <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%2</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="title">@func_counter</span></span><br><span class="line">  <span class="keyword">call</span> <span class="type">void</span> <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%2</span>)</span><br><span class="line">  <span class="keyword">ret</span> <span class="type">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>优势</strong>：</p>
<ul>
<li>保证变量值在函数调用间保持（持久化状态）</li>
<li>避免栈上分配，减少栈帧大小</li>
<li>符合 C 语言 static 变量语义</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>数组元素访问</strong>：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%addr</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> [<span class="number">10</span> <span class="keyword">x</span> <span class="type">i32</span>]<span class="punctuation">,</span> [<span class="number">10</span> <span class="keyword">x</span> <span class="type">i32</span>]* <span class="variable">%arr</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%index</span></span><br><span class="line"><span class="variable">%val</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%addr</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="6-3-2-控制流处理">6.3.2 控制流处理</h4>
<ul>
<li>
<p><strong>if-else 语句</strong>：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%cond</span><span class="punctuation">,</span> <span class="type">label</span> <span class="variable">%then</span><span class="punctuation">,</span> <span class="type">label</span> <span class="variable">%else</span></span><br><span class="line"><span class="symbol">then:</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">br</span> <span class="type">label</span> <span class="variable">%end</span></span><br><span class="line"><span class="symbol">else:</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">br</span> <span class="type">label</span> <span class="variable">%end</span></span><br><span class="line"><span class="symbol">end:</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>for 循环</strong>：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">br</span> <span class="type">label</span> <span class="variable">%cond</span></span><br><span class="line"><span class="symbol">cond:</span></span><br><span class="line">  <span class="variable">%c</span> <span class="operator">=</span> ...</span><br><span class="line">  <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%c</span><span class="punctuation">,</span> <span class="type">label</span> <span class="variable">%body</span><span class="punctuation">,</span> <span class="type">label</span> <span class="variable">%end</span></span><br><span class="line"><span class="symbol">body:</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">br</span> <span class="type">label</span> <span class="variable">%step</span></span><br><span class="line"><span class="symbol">step:</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">br</span> <span class="type">label</span> <span class="variable">%cond</span></span><br><span class="line"><span class="symbol">end:</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>短路求值</strong>（<code>&amp;&amp;</code> / <code>||</code>）：</p>
<ul>
<li>
<p><strong>实现策略</strong>：基于条件分支的惰性求值，避免不必要的计算</p>
</li>
<li>
<p><strong><code>&amp;&amp;</code> 短路逻辑</strong>：</p>
<ol>
<li>计算左操作数，结果存入 <code>%left</code></li>
<li>创建三个基本块：<code>evalRight</code>（计算右操作数）、<code>shortCircuit</code>（短路跳过）、<code>end</code>（合并结果）</li>
<li>若 <code>%left</code> 为 false，直接跳转到 <code>end</code>，结果为 0（false）</li>
<li>若 <code>%left</code> 为 true，跳转到 <code>evalRight</code> 计算右操作数</li>
<li>使用 phi 节点在 <code>end</code> 块合并两条路径的结果</li>
</ol>
</li>
<li>
<p><strong><code>||</code> 短路逻辑</strong>：</p>
<ol>
<li>计算左操作数，结果存入 <code>%left</code></li>
<li>若 <code>%left</code> 为 true，直接跳转到 <code>end</code>，结果为 1（true）</li>
<li>若 <code>%left</code> 为 false，计算右操作数</li>
<li>使用 phi 节点合并结果</li>
</ol>
</li>
<li>
<p><strong>示例</strong>（<code>a &amp;&amp; b</code>）：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%left</span> <span class="operator">=</span> &lt;evaluate a&gt;</span><br><span class="line"><span class="variable">%cond</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">ne</span> <span class="type">i32</span> <span class="variable">%left</span><span class="punctuation">,</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%cond</span><span class="punctuation">,</span> <span class="type">label</span> <span class="variable">%evalRight</span><span class="punctuation">,</span> <span class="type">label</span> <span class="variable">%end</span></span><br><span class="line">evalRight:</span><br><span class="line">  <span class="variable">%right</span> <span class="operator">=</span> &lt;evaluate b&gt;</span><br><span class="line">  <span class="variable">%rcond</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">ne</span> <span class="type">i32</span> <span class="variable">%right</span><span class="punctuation">,</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">br</span> <span class="type">label</span> <span class="variable">%end</span></span><br><span class="line"><span class="symbol">end:</span></span><br><span class="line">  <span class="variable">%result</span> <span class="operator">=</span> <span class="keyword">phi</span> <span class="type">i1</span> [<span class="number">0</span><span class="punctuation">,</span> <span class="variable">%entry</span>]<span class="punctuation">,</span> [<span class="variable">%rcond</span><span class="punctuation">,</span> <span class="variable">%evalRight</span>]</span><br><span class="line">  <span class="variable">%final</span> <span class="operator">=</span> <span class="keyword">zext</span> <span class="type">i1</span> <span class="variable">%result</span> <span class="keyword">to</span> <span class="type">i32</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>优势</strong>：</p>
<ul>
<li>避免无效计算：当 <code>a &amp;&amp; b</code> 中 a 为 false 时，不计算 b</li>
<li>支持副作用控制：如 <code>p != NULL &amp;&amp; *p == 0</code>，防止空指针解引用</li>
<li>符合 C 语言语义标准</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-3-3-函数调用">6.3.3 函数调用</h4>
<ul>
<li>
<p><strong>参数传递</strong>：</p>
<ul>
<li>标量参数：直接传值（<code>i32 %val</code>）</li>
<li>数组参数：传递指针（<code>i32* %arr</code>）</li>
<li>数组首地址通过 <code>getelementptr</code> 提取</li>
</ul>
</li>
<li>
<p><strong>返回值处理</strong>：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%ret</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i32</span> <span class="title">@func</span>(<span class="type">i32</span> <span class="variable">%arg1</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%arg2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>内建函数</strong>：</p>
<ul>
<li><code>getint()</code>：读取整数</li>
<li><code>putint(i32)</code>：输出整数</li>
<li><code>putch(i32)</code>：输出字符</li>
<li><code>putstr(i8*)</code>：输出字符串</li>
</ul>
</li>
</ul>
<h4 id="6-3-4-printf-转换">6.3.4 printf 转换</h4>
<p>将 <code>printf</code> 转换为 <code>putint</code>、<code>putch</code>、<code>putstr</code> 的组合：</p>
<ul>
<li>
<p><strong>解析格式串</strong>：提取 <code>%d</code> 占位符位置</p>
</li>
<li>
<p><strong>分段输出</strong>：普通字符串与整数值交替输出</p>
</li>
<li>
<p><strong>参数求值顺序处理</strong>：</p>
<ul>
<li>
<p><strong>问题</strong>：C 语言中函数参数的求值顺序是未定义的（unspecified），但 SysY 要求从左到右求值</p>
</li>
<li>
<p><strong>解决方案</strong>：在生成 <code>putint</code> 调用前，<strong>预先按顺序计算所有实参表达式</strong>，将结果存入临时寄存器</p>
</li>
<li>
<p><strong>具体实现</strong>：</p>
<ol>
<li>第一遍遍历：按顺序计算所有实参表达式（包括可能包含函数调用的复杂表达式），存储到 <code>ArrayList&lt;Value&gt; evaluatedArgs</code></li>
<li>第二遍遍历：按格式串解析结果，依次生成 <code>putstr</code> 和 <code>putint</code> 调用，使用预先计算好的参数值</li>
<li>确保即使实参中包含有副作用的函数调用（如 <code>getint()</code>），也能保证从左到右的求值顺序</li>
</ol>
</li>
<li>
<p><strong>示例说明</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, getint(), getint());</span><br></pre></td></tr></table></figure>
<p>生成的 IR（简化）：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 第一步：按顺序求值所有实参</span></span><br><span class="line"><span class="variable">%arg1</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i32</span> <span class="title">@getint</span>()    <span class="comment">; 第一个实参先求值</span></span><br><span class="line"><span class="variable">%arg2</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i32</span> <span class="title">@getint</span>()    <span class="comment">; 第二个实参后求值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 第二步：按格式串输出</span></span><br><span class="line"><span class="keyword">call</span> <span class="type">void</span> <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%arg1</span>)  <span class="comment">; 输出第一个整数</span></span><br><span class="line"><span class="keyword">call</span> <span class="type">void</span> <span class="title">@putch</span>(<span class="type">i32</span> <span class="number">32</span>)      <span class="comment">; 输出空格</span></span><br><span class="line"><span class="keyword">call</span> <span class="type">void</span> <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%arg2</span>)  <span class="comment">; 输出第二个整数</span></span><br><span class="line"><span class="keyword">call</span> <span class="type">void</span> <span class="title">@putch</span>(<span class="type">i32</span> <span class="number">10</span>)      <span class="comment">; 输出换行</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>关键点</strong>：</p>
<ul>
<li>避免了参数求值顺序不确定导致的输出错误</li>
<li>支持实参表达式中包含函数调用、数组访问等复杂操作</li>
<li>保证与 SysY 语义一致</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>完整示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d, y=%d\n&quot;</span>, x, y);</span><br></pre></td></tr></table></figure>
<p>转换为：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> <span class="type">void</span> <span class="title">@putstr</span>(<span class="type">i8</span>* <span class="keyword">getelementptr</span>([<span class="number">3</span> <span class="keyword">x</span> <span class="type">i8</span>]<span class="punctuation">,</span> [<span class="number">3</span> <span class="keyword">x</span> <span class="type">i8</span>]* <span class="title">@.str.0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span>))  <span class="comment">; &quot;x=&quot;</span></span><br><span class="line"><span class="keyword">call</span> <span class="type">void</span> <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%x</span>)</span><br><span class="line"><span class="keyword">call</span> <span class="type">void</span> <span class="title">@putstr</span>(<span class="type">i8</span>* <span class="keyword">getelementptr</span>([<span class="number">4</span> <span class="keyword">x</span> <span class="type">i8</span>]<span class="punctuation">,</span> [<span class="number">4</span> <span class="keyword">x</span> <span class="type">i8</span>]* <span class="title">@.str.1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span>))  <span class="comment">; &quot;, y=&quot;</span></span><br><span class="line"><span class="keyword">call</span> <span class="type">void</span> <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%y</span>)</span><br><span class="line"><span class="keyword">call</span> <span class="type">void</span> <span class="title">@putch</span>(<span class="type">i32</span> <span class="number">10</span>)  <span class="comment">; &#x27;\n&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-4-类型系统与值表示">6.4 类型系统与值表示</h3>
<h4 id="Value-抽象">Value 抽象</h4>
<ul>
<li><code>IMMEDIATE</code>：立即数（如 <code>42</code>）</li>
<li><code>REGISTER</code>：虚拟寄存器（如 <code>%1</code>）</li>
<li><code>GLOBAL</code>：全局变量（如 <code>@arr</code>）</li>
</ul>
<h4 id="Addr-抽象">Addr 抽象</h4>
<ul>
<li>封装变量地址（寄存器或全局符号）</li>
<li>支持 <code>load</code> / <code>store</code> 操作</li>
</ul>
<h4 id="LocalVar">LocalVar</h4>
<ul>
<li>变量名、地址、类型、数组维度</li>
<li>数组大小信息（用于 <code>getelementptr</code> 计算）</li>
</ul>
<h3 id="6-5-设计亮点">6.5 设计亮点</h3>
<table>
<thead>
<tr>
<th>亮点</th>
<th>价值</th>
</tr>
</thead>
<tbody>
<tr>
<td>SSA 形式</td>
<td>简化数据流分析，便于后续优化</td>
</tr>
<tr>
<td>作用域深度追踪</td>
<td>支持变量遮蔽与生命周期管理</td>
</tr>
<tr>
<td>字符串常量池</td>
<td>避免重复字符串，减少代码体积</td>
</tr>
<tr>
<td>短路求值优化</td>
<td>减少不必要的计算，提升运行效率</td>
</tr>
<tr>
<td>printf 智能转换</td>
<td>将格式化输出转换为高效的运行时库调用</td>
</tr>
<tr>
<td>可插拔优化框架</td>
<td>支持灵活添加各类优化 pass</td>
</tr>
<tr>
<td>统一的值抽象（Value）</td>
<td>简化表达式生成逻辑，支持立即数与寄存器统一处理</td>
</tr>
</tbody>
</table>
<h3 id="6-6-优化框架设计">6.6 优化框架设计</h3>
<p>本项目的中端优化采用可插拔的 pass 框架，源码位于 <code>src/midend/opt</code>。核心部件包括：</p>
<ul>
<li><code>OptimizationPass.java</code>：优化 pass 的接口契约。每个 pass 至少应实现 <code>String run(String ir)</code>（对整个模块文本 IR 做变换并返回新 IR），并可使用 <code>normalizeIndent(String)</code> 做行级缩进规范化。<br>
<code>PassManager.java</code>：负责按 <code>OptimizationOptions</code> 中的开关构建 pass 列表，并按序执行（<code>runAll(String ir)</code>）。在执行前以及所有 pass 执行完后各调用一次 <code>PassManager.normalizeIr(String)</code> 做统一预处理（即只在开始和结束各调用一次，而不是在每个 pass 之后）：移除行内注释（保留字符串常量内的分号）、合并多余空行，并统一基本块标签与指令缩进，以避免注释或格式差异干扰基于行/正则的匹配。</li>
<li><code>OptimizationOptions.java</code>：开关配置（例如 <code>enableMem2Reg</code>, <code>enableInstSimplify</code>, <code>enableConstProp</code>, <code>enableStrengthReduction</code>, <code>enableGVN</code>, <code>enableLoopUnrolling</code>, <code>enableFunctionInlining</code>, <code>enableDCE</code>, <code>enableCFGSimplify</code>, <code>enableTailCallOptimization</code> 等），用于在 <code>PassManager</code> 构建时决定哪些 pass 被注入以及是否重复插入第二轮。</li>
<li>若要运行并验证效果，请使用测试驱动 <code>src/midend/opt/OptimizationTest.java</code>，它包含若干最小复现用例和 <code>testCombined()</code> 用于做多轮/组合优化验证并打印每步差异。最近新增了针对 <code>InstSimplifyPass</code> 中 icmp/zext 链折叠的单元用例，以及针对 <code>PassManager.normalizeIr</code> 的格式化/注释移除验证用例。</li>
</ul>
<p>主要设计原则</p>
<ul>
<li>文本友好与可观测：当前 pass 以“文本 + 行级正则/模式”方式实现，便于调试与快速迭代，但对 IR 格式（缩进、空行、注释）敏感。因此约定使用 <code>PassManager.normalizeIr</code>（集中处理行内注释、空行与缩进）与 <code>OptimizationPass.normalizeIndent</code> 做简单规范化。</li>
<li>可插拔与配置化：通过 <code>OptimizationOptions</code> 控制每个 pass 的启用，<code>PassManager</code> 按顺序将所选 pass 串联在一起；新增或删除 pass 只需实现/移除对应的 <code>OptimizationPass</code> 实现并更新 <code>PassManager</code> 注册或测试中的局部注册点。</li>
<li>多轮与收敛：部分 pass（如常量传播、指令简化、强度削减、GVN）可能需要多轮交替运行才能收敛。<code>PassManager</code> 已在构造器中为这些 pass 预置了两轮运行的位置（第一轮与第二轮），但也支持在测试/工具中按需做“迭代直到不变点”的策略。</li>
</ul>
<p>推荐的默认执行顺序（实现中顺序）</p>
<p>Pass 的实际注入顺序由 <code>PassManager(OptimizationOptions)</code> 构建，当前实现的经验顺序如下（亦见 <code>PassManager</code> 源码）：</p>
<ol>
<li>SSA 可选转换（<code>SSATransformPass</code>，llvm默认已经是SSA的，置空）</li>
<li><code>Mem2RegPass</code>（内存到寄存器提升，插入 phi 节点）</li>
<li><code>PhiEliminationPass</code>（Phi 删除，基于内存展开 phi 节点）</li>
<li><code>FunctionInliningPass</code>（函数内联）</li>
<li><code>InstSimplifyPass</code>（指令级简化、常量折叠、代数规则）</li>
<li><code>ConstantPropagationPass</code>（常量传播）</li>
<li><code>StrengthReductionPass</code>（强度削减，乘除→移位等）</li>
<li><code>GVNPass</code>（全局值编号，公共子表达式消除）</li>
<li><code>LoopUnrollingPass</code>（循环展开）</li>
<li>第二轮 <code>InstSimplify</code> / <code>ConstantPropagation</code> / <code>StrengthReduction</code> / <code>GVN</code>（收敛清理）</li>
<li><code>DeadCodeEliminationPass</code>（删除不可达/无用指令）</li>
<li><code>CFGSimplifyPass</code>（控制流简化：常量分支折叠、死块删除）</li>
<li><code>TailCallOptimizationPass</code>（尾调用/尾递归转换）</li>
<li>最终 <code>DeadCodeEliminationPass</code>（再次清理）</li>
</ol>
<p>各 Pass 简短说明（与源码一一对应）</p>
<ul>
<li><code>SSATransformPass</code>：可选的 SSA 重写（项目内前端已做部分 SSA，运行此 pass 为可选）。</li>
<li><code>Mem2RegPass</code>：识别可提升的 <code>alloca</code> 并把栈上变量提升为寄存器（使用 phi 合并），以便减少 load/store 干扰。</li>
<li><code>PhiEliminationPass</code>：单独实现的 Phi 删除 Pass。该 Pass 将 SSA 中的 <code>phi</code> 节点通过基于内存的方式展开为普通指令序列，便于后续基于文本的优化（如 <code>InstSimplify</code>、<code>GVN</code> 等）更可靠地识别和处理值流。</li>
<li><code>FunctionInliningPass</code>：内联小函数（含递归检测、寄存器重命名与阈值），内联会产生更多的常量/局部化机会，需紧随清理 pass。内联实现已改进以不输出以 <code>;</code> 开头的行内注释，从而避免把调试注释混入最终 IR。</li>
<li><code>InstSimplifyPass</code>：做局部指令简化与常量折叠（例如消除无意义的 zext、把 add 0/eliminate、常量表达式直接折叠成立即数）。近期增强：识别并折叠连续的 <code>zext</code>/<code>icmp</code> 链（例如 <code>zext i1 -&gt; i32</code> 后接 <code>icmp eq/ne i32, 0</code>），将分支条件恢复为原始 i1 并在必要时交换分支目标，从而显著简化常见的逻辑序列。</li>
<li><code>ConstantPropagationPass</code>：跨指令传播常量并替换寄存器为常量立即数，常与 GVN/InstSimplify 联合提升效果。</li>
<li><code>StrengthReductionPass</code>：将高成本算术（乘法/除法）转换为低成本等价（移位/加法）当满足模式时。</li>
<li><code>GVNPass</code>：全局值编号以检测并消除基本块间的公共子表达式，复用先前计算的值。</li>
<li><code>LoopUnrollingPass</code>：对小循环做完全或部分展开以提高后续优化与并行机会，同时受展开阈值控制以避免代码爆炸。</li>
<li><code>DeadCodeEliminationPass</code>：删除无用指令与不可达代码，是收敛流程中频繁使用的清理工具。近期改进：在删除死赋值前，先在函数内部执行基于标签可达性分析的不可达基本块删除（removing unreachable blocks），从而能移除包含 <code>unreachable</code> 或从入口不可达的整块代码及其内部不再被引用的定义。</li>
<li><code>CFGSimplifyPass</code>：基于分支常量化和基本块可达性分析做控制流层面的简化。近期增强：对无显式标签的函数，也会在必要时插入保守的 <code>unreachable</code> 终结指令，保证每个函数在语法层面具有终结器。</li>
<li><code>TailCallOptimizationPass</code>：将尾递归或可转化的尾调用改写为循环形式以节省栈深度。</li>
</ul>
<h2 id="7-目标代码生成设计">7. 目标代码生成设计</h2>
<h3 id="7-1-总体架构">7.1 总体架构</h3>
<p>目标代码生成阶段将优化后的LLVM IR转换为MIPS汇编代码。主要组件：</p>
<ul>
<li><strong>MIPSGenerator.java</strong>：主生成器，负责解析IR并生成MIPS指令</li>
<li><strong>MIPSContext.java</strong>：上下文管理器，维护寄存器分配、栈偏移、符号映射等状态</li>
</ul>
<h3 id="7-2-自定义栈帧布局">7.2 自定义栈帧布局</h3>
<h4 id="栈帧结构">栈帧结构</h4>
<p>本项目采用<strong>帧指针（$fp）为基准</strong>的栈帧布局，兼容MARS模拟器的调用约定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">高地址</span><br><span class="line">+----------------+</span><br><span class="line">| 第n个参数      | +4*(n-1)($fp)  ; 第5个及以上参数（如果有）</span><br><span class="line">| ...            |</span><br><span class="line">| 第5个参数      | +16($fp)</span><br><span class="line">| 第4个参数      | +12($fp)</span><br><span class="line">| 第3个参数      | +8($fp)</span><br><span class="line">| 第2个参数      | +4($fp)</span><br><span class="line">| 第1个参数      | +0($fp)         ; 参数1-4也会备份到栈上</span><br><span class="line">+----------------+ &lt;- $fp (新) = $sp (旧)</span><br><span class="line">| $ra            | -4($fp)         ; 返回地址</span><br><span class="line">| $fp (旧)       | -8($fp)         ; 调用者的帧指针</span><br><span class="line">+----------------+</span><br><span class="line">| $t0 (临时0)    | -12($fp)        ; 临时寄存器保存区开始</span><br><span class="line">| $t1 (临时1)    | -16($fp)</span><br><span class="line">| ...            |</span><br><span class="line">| $t19 (临时19)  | -12-19*4($fp)   ; 共20个临时寄存器（$8-$27）</span><br><span class="line">+----------------+</span><br><span class="line">| alloca变量1    | -92($fp)        ; 局部变量区（动态分配）</span><br><span class="line">| alloca变量2    |</span><br><span class="line">| alloca数组     |</span><br><span class="line">| phi临时变量    |</span><br><span class="line">| spill槽        |</span><br><span class="line">+----------------+ &lt;- $sp (新，低地址）</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure>
<h4 id="设计要点">设计要点</h4>
<ol>
<li><strong>参数传递</strong>：
<ul>
<li>前4个参数通过<code>$a0-$a3</code>传递</li>
<li>第5个及以上参数通过栈传递，位于$fp正偏移</li>
<li>即使参数在寄存器传递，函数入口也会将其备份到栈上（<code>+0($fp)</code>到<code>+12($fp)</code>）</li>
</ul>
</li>
<li><strong>临时寄存器区</strong>：
<ul>
<li>固定预留20个字（80字节）用于保存<code>$t0-$t19</code>（即MIPS的<code>$8-$27</code>）</li>
<li>函数调用前保存，返回后恢复</li>
<li>仅保存<strong>已使用</strong>的临时寄存器（通过<code>usedTempRegs</code>跟踪）</li>
</ul>
</li>
<li><strong>局部变量区</strong>：
<ul>
<li>所有<code>alloca</code>指令分配的变量/数组</li>
<li>Phi消除后产生的<code>%phi_slot*</code>变量</li>
<li>动态计算栈空间大小，避免重叠</li>
</ul>
</li>
</ol>
<h4 id="栈帧大小计算">栈帧大小计算</h4>
<p>栈帧大小由以下部分组成，在函数解析前通过两遍扫描精确计算：</p>
<h5 id="第一遍：活跃变量峰值分析">第一遍：活跃变量峰值分析</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描函数体，记录每个变量的定义位置和最后使用位置</span></span><br><span class="line">Map&lt;String, Integer&gt; lastUse = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">Map&lt;String, Integer&gt; defIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算每一时刻的活跃变量数量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peakLive</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; totalLines; idx++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">liveCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String <span class="keyword">var</span> : defIndex.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (defIndex.get(<span class="keyword">var</span>) &lt;= idx &amp;&amp; lastUse.get(<span class="keyword">var</span>) &gt;= idx) &#123;</span><br><span class="line">            liveCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    peakLive = Math.max(peakLive, liveCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为活跃变量峰值预留 Spill 槽</span></span><br><span class="line">funcInfo.tempSpillCount = Math.max(funcInfo.tempSpillCount, peakLive);</span><br></pre></td></tr></table></figure>
<h5 id="第二遍：统计栈使用情况">第二遍：统计栈使用情况</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计各类资源使用</span></span><br><span class="line"><span class="keyword">while</span> (scanning function body) &#123;</span><br><span class="line">    <span class="keyword">if</span> (line.contains(<span class="string">&quot;alloca&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 记录局部变量/数组大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> extractArraySize(line);</span><br><span class="line">        funcInfo.allocas.put(varName, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (line.contains(<span class="string">&quot;call&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 记录最大参数数量（用于调用栈预留）</span></span><br><span class="line">        funcInfo.hasCall = <span class="literal">true</span>;</span><br><span class="line">        funcInfo.maxArgs = Math.max(funcInfo.maxArgs, argCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记实际使用的变量（未使用的不分配空间）</span></span><br><span class="line">    <span class="keyword">if</span> (line references allocaVar) &#123;</span><br><span class="line">        funcInfo.usedAllocas.add(allocaVar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最终大小计算">最终大小计算</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">calculateStackSize</span><span class="params">(FunctionInfo funcInfo)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 基础空间：$ra + $fp</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">baseSize</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 临时寄存器保存区：20个寄存器 × 4字节</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">tempregSize</span> <span class="operator">=</span> <span class="number">20</span> * <span class="number">4</span>;  <span class="comment">// 80字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Spill 槽：活跃变量峰值 + 安全余量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SPILL_SAFETY_MARGIN</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">spillSize</span> <span class="operator">=</span> (funcInfo.tempSpillCount + SPILL_SAFETY_MARGIN) * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 局部变量区：仅统计实际使用的 alloca</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">usedAllocaSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e : funcInfo.allocas.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (funcInfo.usedAllocas.contains(e.getKey())) &#123;</span><br><span class="line">            usedAllocaSize += e.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 调用参数预留区：支持嵌套调用</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxArgs</span> <span class="operator">=</span> funcInfo.maxArgs * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 总大小（16字节对齐）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">totalSize</span> <span class="operator">=</span> baseSize + tempregSize + spillSize + usedAllocaSize + maxArgs;</span><br><span class="line">    totalSize = ((totalSize + <span class="number">15</span>) / <span class="number">16</span>) * <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    funcInfo.stackSize = totalSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="示例计算">示例计算</h5>
<p>假设函数 <code>foo(a, b, c)</code> 有：</p>
<ul>
<li>2个局部变量（8字节）</li>
<li>1个数组 <code>[10 x i32]</code>（40字节）</li>
<li>活跃变量峰值 5 个</li>
<li>调用其他函数传递 3 个参数</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">栈帧大小 = </span><br><span class="line">    8 (RA/FP) +</span><br><span class="line">    80 (临时寄存器区) +</span><br><span class="line">    (5 + 40) * 4 = 180 (Spill槽) +</span><br><span class="line">    48 (局部变量) +</span><br><span class="line">    12 (调用参数区) </span><br><span class="line">    = 328 字节</span><br><span class="line">    </span><br><span class="line">对齐到16字节 = 336 字节</span><br></pre></td></tr></table></figure>
<p><strong>优化亮点</strong>：</p>
<ol>
<li><strong>按需分配</strong>：未使用的 <code>alloca</code> 变量不占用栈空间。</li>
<li><strong>精确预估</strong>：通过活跃变量分析避免过度预留 Spill 槽。</li>
<li><strong>安全余量</strong>：预留 40 字节防止优化导致的低估。</li>
</ol>
<h3 id="7-3-寄存器分配与管理策略">7.3 寄存器分配与管理策略</h3>
<p>本项目实现了基于<strong>引用计数的寄存器分配</strong>与**Lazy Spill（延迟溢出）**策略，并引入了 <strong>Dirty Bit（脏位）机制</strong>、<strong>Store-to-Load Forwarding</strong>等优化，旨在最大化寄存器利用率并减少内存访问。寄存器分配的核心流程由以下几个关键函数协同完成。</p>
<h4 id="7-3-1-寄存器资源概览">7.3.1 寄存器资源概览</h4>
<p><strong>可用寄存器池</strong>：</p>
<ul>
<li>临时寄存器：<code>$8-$27</code>（20个），用于变量与临时计算</li>
<li>参数寄存器：<code>$a0-$a3</code>（仅用于参数传递）</li>
<li>返回值寄存器：<code>$v0</code>（仅用于返回值）</li>
<li>上下文维护：双向映射 <code>varToReg</code> / <code>regToVar</code>，引用计数表 <code>refCountMap</code></li>
</ul>
<h4 id="7-3-2-底层寄存器分配：nextTempReg">7.3.2 底层寄存器分配：<code>nextTempReg()</code></h4>
<p><strong>职责</strong>：从寄存器池中选择一个物理寄存器，基于引用计数策略优先选择&quot;最不活跃&quot;的寄存器。</p>
<p><strong>实现逻辑</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MIPSContext.nextTempReg()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextTempReg</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 策略1：优先选择完全空闲的寄存器（未使用 + 未映射）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TEMP_REG_NUM; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cand</span> <span class="operator">=</span> TEMP_REG_BEGIN + i;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regName</span> <span class="operator">=</span> <span class="string">&quot;$&quot;</span> + cand;</span><br><span class="line">        <span class="keyword">if</span> (!usedTempRegs.contains(cand) &amp;&amp; !regToVar.containsKey(regName)) &#123;</span><br><span class="line">            usedTempRegs.add(cand);</span><br><span class="line">            <span class="keyword">return</span> cand;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 策略2：选择引用计数最小的寄存器（优先淘汰&quot;不活跃&quot;变量）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">bestReg</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minRefCount</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TEMP_REG_NUM; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cand</span> <span class="operator">=</span> TEMP_REG_BEGIN + i;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regName</span> <span class="operator">=</span> <span class="string">&quot;$&quot;</span> + cand;</span><br><span class="line">        <span class="type">String</span> <span class="variable">var</span> <span class="operator">=</span> regToVar.get(regName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">var</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">refCount</span> <span class="operator">=</span> refCountMap.getOrDefault(<span class="keyword">var</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (refCount &lt; minRefCount) &#123;</span><br><span class="line">                minRefCount = refCount;</span><br><span class="line">                bestReg = cand;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 策略3：轮询分配（兜底）</span></span><br><span class="line">    <span class="keyword">return</span> bestReg != -<span class="number">1</span> ? bestReg : TEMP_REG_BEGIN + (tempRegCounter++ % TEMP_REG_NUM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong>：</p>
<ul>
<li><strong>引用计数驱动</strong>：优先淘汰 <code>refCount == 0</code> 的变量（已无后续使用）</li>
<li><strong>避免频繁 Spill</strong>：通过统计活跃度，减少热点变量被驱逐的概率</li>
<li><strong>引用计数更新</strong>：每次 <code>loadOperand</code> 使用变量时递减计数（见 7.3.5）</li>
</ul>
<h4 id="7-3-3-临时寄存器获取：getTempRegister">7.3.3 临时寄存器获取：<code>getTempRegister()</code></h4>
<p><strong>职责</strong>：在需要临时寄存器时调用，处理旧变量的 Spill（如果需要）并返回可用寄存器。</p>
<p><strong>实现逻辑</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MIPSGenerator.getTempRegister()</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getTempRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">regNum</span> <span class="operator">=</span> context.nextTempReg();  <span class="comment">// 调用底层分配</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="string">&quot;$&quot;</span> + regNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果该寄存器已映射到某个变量，需要先保护旧变量</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">oldVar</span> <span class="operator">=</span> context.getVarForReg(reg);</span><br><span class="line">    <span class="keyword">if</span> (oldVar != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Dirty Bit 检查：仅 Spill 脏变量</span></span><br><span class="line">        <span class="keyword">if</span> (dirtyVars.contains(oldVar)) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">off</span> <span class="operator">=</span> context.getStackOffset(oldVar);</span><br><span class="line">            <span class="keyword">if</span> (off == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> context.getVarSize(oldVar) != <span class="literal">null</span> ? context.getVarSize(oldVar) : <span class="number">4</span>;</span><br><span class="line">                off = context.allocateStack(oldVar, size);</span><br><span class="line">            &#125;</span><br><span class="line">            generateSw(reg, String.valueOf(off), <span class="string">&quot;$fp&quot;</span>);</span><br><span class="line">            dirtyVars.remove(oldVar);  <span class="comment">// Spill 后变 Clean</span></span><br><span class="line">        &#125;</span><br><span class="line">        context.clearRegisterMapping(reg);  <span class="comment">// 解除旧映射</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Store-to-Load Forwarding：清除该寄存器的 forwarding 信息</span></span><br><span class="line">    invalidateForwardingForReg(reg);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> reg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong>：</p>
<ul>
<li><strong>Lazy Spill</strong>：仅在寄存器需要复用时 Spill，而非每次指令后</li>
<li><strong>Dirty Bit 优化</strong>：Clean 变量直接丢弃，减少 95% 的不必要 <code>sw</code></li>
<li><strong>Forwarding 失效</strong>：防止使用过期的 Store-to-Load 缓存</li>
</ul>
<h4 id="7-3-4-变量寄存器分配：allocateRegister-varName">7.3.4 变量寄存器分配：<code>allocateRegister(varName)</code></h4>
<p><strong>职责</strong>：为新生成的变量（如计算结果）分配寄存器，并建立映射关系。</p>
<p><strong>实现逻辑</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MIPSGenerator.allocateRegister()</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">allocateRegister</span><span class="params">(String varName)</span> &#123;</span><br><span class="line">    <span class="comment">// 复用检查：如果变量已有寄存器，直接返回</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">reg</span> <span class="operator">=</span> context.getRegister(varName);</span><br><span class="line">    <span class="keyword">if</span> (reg != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> reg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取新寄存器（可能触发 Spill）</span></span><br><span class="line">    reg = getTempRegister();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建立映射</span></span><br><span class="line">    context.setRegister(varName, reg);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Dirty Bit：新分配的变量标记为 Dirty（计算结果尚未写入栈）</span></span><br><span class="line">    dirtyVars.add(varName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Store-to-Load Forwarding：清除该寄存器的 forwarding 信息</span></span><br><span class="line">    invalidateForwardingForReg(reg);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> reg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong>：</p>
<ul>
<li><strong>自动 Dirty 标记</strong>：新计算的结果默认为 Dirty，确保后续会被 Spill</li>
<li><strong>映射管理</strong>：通过 <code>context.setRegister</code> 更新双向映射表</li>
<li><strong>防止 Forwarding 错误</strong>：新变量分配后，该寄存器的旧 forwarding 信息失效</li>
</ul>
<h4 id="7-3-5-操作数加载：loadOperand-operand">7.3.5 操作数加载：<code>loadOperand(operand)</code></h4>
<p><strong>职责</strong>：将操作数（常量、变量、全局符号）加载到寄存器，是寄存器分配的&quot;消费端&quot;。</p>
<p><strong>实现逻辑</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MIPSGenerator.loadOperand()</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">loadOperand</span><span class="params">(String operand)</span> &#123;</span><br><span class="line">    <span class="comment">// 情况1：常量立即数</span></span><br><span class="line">    <span class="keyword">if</span> (operand.matches(<span class="string">&quot;-?\\d+&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">reg</span> <span class="operator">=</span> getTempRegister();</span><br><span class="line">        mipsCode.append(<span class="string">&quot;    li &quot;</span>).append(reg).append(<span class="string">&quot;, &quot;</span>).append(operand).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> reg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 情况2：变量（去除 % 前缀）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">varName</span> <span class="operator">=</span> operand.startsWith(<span class="string">&quot;%&quot;</span>) ? operand.substring(<span class="number">1</span>) : operand;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.1 寄存器复用：变量已在寄存器中</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">existingReg</span> <span class="operator">=</span> context.getRegister(varName);</span><br><span class="line">    <span class="keyword">if</span> (existingReg != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 引用计数递减（该变量被使用一次）</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">refCount</span> <span class="operator">=</span> refCountMap.get(varName);</span><br><span class="line">        <span class="keyword">if</span> (refCount != <span class="literal">null</span> &amp;&amp; refCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            refCountMap.put(varName, refCount - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> existingReg;  <span class="comment">// 直接复用</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.2 从栈加载：变量在栈上</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">offset</span> <span class="operator">=</span> context.getStackOffset(varName);</span><br><span class="line">    <span class="keyword">if</span> (offset != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">reg</span> <span class="operator">=</span> getTempRegister();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// getelementptr 特殊处理：区分&quot;地址&quot;和&quot;值&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (context.getPointerOrigin(varName) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 栈上存的是地址，先加载地址再从地址加载值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">addrReg</span> <span class="operator">=</span> getTempRegister();</span><br><span class="line">            generateLw(addrReg, String.valueOf(offset), <span class="string">&quot;$fp&quot;</span>);</span><br><span class="line">            generateLw(reg, <span class="string">&quot;0&quot;</span>, addrReg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 栈上存的是值，直接加载</span></span><br><span class="line">            generateLw(reg, String.valueOf(offset), <span class="string">&quot;$fp&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从栈加载的变量是 Clean 的（栈上已有副本）</span></span><br><span class="line">        <span class="comment">// 不加入 dirtyVars</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 引用计数递减</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">refCount</span> <span class="operator">=</span> refCountMap.get(varName);</span><br><span class="line">        <span class="keyword">if</span> (refCount != <span class="literal">null</span> &amp;&amp; refCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            refCountMap.put(varName, refCount - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> reg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 情况3：全局变量</span></span><br><span class="line">    <span class="keyword">if</span> (context.isGlobalVar(varName)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">baseReg</span> <span class="operator">=</span> getTempRegister();</span><br><span class="line">        <span class="type">String</span> <span class="variable">reg</span> <span class="operator">=</span> getTempRegister();</span><br><span class="line">        mipsCode.append(<span class="string">&quot;    la &quot;</span>).append(baseReg).append(<span class="string">&quot;, &quot;</span>).append(varName).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        generateLw(reg, <span class="string">&quot;0&quot;</span>, baseReg);</span><br><span class="line">        <span class="keyword">return</span> reg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 兜底：返回零寄存器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;$zero&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong>：</p>
<ul>
<li><strong>寄存器复用</strong>：优先返回已分配的寄存器，避免重复加载</li>
<li><strong>引用计数递减</strong>：每次使用后递减，为后续 <code>nextTempReg()</code> 提供淘汰依据</li>
<li><strong>Clean 标记</strong>：从栈加载的变量不标记为 Dirty（栈上已有副本）</li>
<li><strong>getelementptr 语义修正</strong>：区分&quot;地址&quot;和&quot;值&quot;，防止输出地址而非元素值</li>
</ul>
<h4 id="7-3-6-寄存器-Spill-策略：spillAllRegisters">7.3.6 寄存器 Spill 策略：<code>spillAllRegisters()</code></h4>
<p><strong>职责</strong>：在基本块边界或函数调用前，将所有活跃的 Dirty 变量写回栈。</p>
<p><strong>实现逻辑</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MIPSGenerator.spillAllRegisters()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">spillAllRegisters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 收集需要 Spill 的变量信息</span></span><br><span class="line">    List&lt;SpillInfo&gt; toSpill = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; regs = context.getNeedSaveTempRegsList();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Integer regNum : regs) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="string">&quot;$&quot;</span> + regNum;</span><br><span class="line">        <span class="type">String</span> <span class="variable">var</span> <span class="operator">=</span> context.getVarForReg(reg);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">var</span> != <span class="literal">null</span> &amp;&amp; dirtyVars.contains(<span class="keyword">var</span>)) &#123;  <span class="comment">// 仅 Spill Dirty 变量</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">off</span> <span class="operator">=</span> context.getStackOffset(<span class="keyword">var</span>);</span><br><span class="line">            <span class="keyword">if</span> (off == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> context.getVarSize(<span class="keyword">var</span>) != <span class="literal">null</span> ? context.getVarSize(<span class="keyword">var</span>) : <span class="number">4</span>;</span><br><span class="line">                off = context.allocateStack(<span class="keyword">var</span>, size);</span><br><span class="line">            &#125;</span><br><span class="line">            toSpill.add(<span class="keyword">new</span> <span class="title class_">SpillInfo</span>(reg, <span class="keyword">var</span>, off));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按栈偏移排序，利用缓存局部性</span></span><br><span class="line">    toSpill.sort((a, b) -&gt; Integer.compare(a.offset, b.offset));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 批量生成 Spill 指令</span></span><br><span class="line">    <span class="keyword">for</span> (SpillInfo info : toSpill) &#123;</span><br><span class="line">        generateSw(info.reg, String.valueOf(info.offset), <span class="string">&quot;$fp&quot;</span>);</span><br><span class="line">        dirtyVars.remove(info.<span class="keyword">var</span>);  <span class="comment">// Spill 后变 Clean</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化效果</strong>：</p>
<ul>
<li><strong>Dirty Bit 过滤</strong>：仅保存修改过的变量，减少 95% 的无效 <code>sw</code></li>
<li><strong>批量排序</strong>：按内存地址顺序写入，提升缓存命中率</li>
</ul>
<h4 id="7-3-7-基本块边界处理">7.3.7 基本块边界处理</h4>
<p><strong>触发时机</strong>：</p>
<ul>
<li>进入新基本块（标签 <code>label:</code>）</li>
<li>分支跳转前（<code>br</code> / <code>j</code>）</li>
<li>函数调用前（<code>call</code>）</li>
</ul>
<p><strong>处理流程</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入新基本块</span></span><br><span class="line"><span class="keyword">if</span> (line.endsWith(<span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">    spillAllRegisters();               <span class="comment">// 保存所有 Dirty 变量</span></span><br><span class="line">    clearForwardingInfo();             <span class="comment">// 清除 Store-to-Load 缓存</span></span><br><span class="line">    mipsCode.append(label).append(<span class="string">&quot;:\n&quot;</span>);</span><br><span class="line">    context.clearAllRegisterMappings(); <span class="comment">// 清除寄存器映射</span></span><br><span class="line">    context.resetTempRegs();           <span class="comment">// 重置临时寄存器标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分支跳转前</span></span><br><span class="line">spillAllRegisters();</span><br><span class="line">clearForwardingInfo();</span><br><span class="line">mipsCode.append(<span class="string">&quot;    j &quot;</span>).append(targetLabel).append(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>原因</strong>：</p>
<ul>
<li>新基本块可能有多个前驱，寄存器状态不确定</li>
<li>必须通过栈传递变量值，确保语义正确</li>
<li>Forwarding 缓存仅在单个基本块内有效</li>
</ul>
<h4 id="7-3-8-避开指定寄存器的分配：getTempRegisterAvoid-avoidReg">7.3.8 避开指定寄存器的分配：<code>getTempRegisterAvoid(avoidReg)</code></h4>
<p><strong>场景</strong>：同一指令的两个操作数如果落在同一物理寄存器会相互覆盖，需要拿到一个“不是 avoidReg” 的寄存器。常见于交换/比较指令左、右操作数冲突时的兜底分配。</p>
<p><strong>实现要点</strong>：</p>
<ul>
<li>尝试两次 <code>nextTempReg()</code>，遇到与 <code>avoidReg</code> 相同则跳过；否则按常规流程复用/Spill 脏变量、清 forwarding。</li>
<li>如两次都撞上或没有更优选择，退回 <code>getTempRegister()</code>，极端情况下允许返回 <code>avoidReg</code> 以保证可用性。</li>
<li>Spill 时同样仅对脏变量落栈，并在复用后清除寄存器映射与 forwarding 信息，保持 Lazy Spill 语义。</li>
</ul>
<h4 id="7-3-9-强制重新加载操作数：reloadOperandFresh-operand-avoidReg">7.3.9 强制重新加载操作数：<code>reloadOperandFresh(operand, avoidReg)</code></h4>
<p><strong>目的</strong>：当两个不同操作数被分配到同一寄存器（例如共用一条寄存器映射或立即数装载到冲突寄存器）时，强制把 <code>operand</code> 重新装入一个避开 <code>avoidReg</code> 的新寄存器，消除覆盖风险。</p>
<p><strong>处理分支</strong>：</p>
<ul>
<li>立即数：直接用 <code>getTempRegisterAvoid</code> 拿新寄存器，<code>li</code> 装载。</li>
<li><code>%var</code>：优先从栈偏移重新加载；若有寄存器映射则复制一份；全局符号回退为 <code>la</code>，否则默认 <code>li 0</code> 兜底。重新加载后会通过 <code>context.setRegister</code> 更新映射，使后续使用指向最新副本。</li>
<li><code>@global</code>：<code>la</code> 到新寄存器即可。</li>
</ul>
<p><strong>关键收益</strong>：</p>
<ul>
<li>保证二元指令左右操作数的寄存器互不覆盖，避免 <code>sw</code>/<code>add</code> 等写回破坏另一操作数。</li>
<li>与 <code>getTempRegisterAvoid</code> 协同工作，在保持 Lazy Spill 的同时，为冲突场景提供低侵入的安全修正。</li>
</ul>
<h3 id="7-4-内存分配与访问">7.4 内存分配与访问</h3>
<h4 id="7-4-1-变量访问模式">7.4.1 变量访问模式</h4>
<p><strong>全局变量访问</strong>：</p>
<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">la $<span class="built_in">t0</span>, global_var    <span class="comment"># 加载地址</span></span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">t1</span>, <span class="number">0</span>($<span class="built_in">t0</span>)        <span class="comment"># 读取值</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">t2</span>, <span class="number">0</span>($<span class="built_in">t0</span>)        <span class="comment"># 存储值</span></span><br></pre></td></tr></table></figure>
<p><strong>局部变量访问</strong>：</p>
<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lw </span>$<span class="built_in">t0</span>, -<span class="number">100</span>($<span class="built_in">fp</span>)     <span class="comment"># 从栈加载</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">t1</span>, -<span class="number">100</span>($<span class="built_in">fp</span>)     <span class="comment"># 存储到栈</span></span><br></pre></td></tr></table></figure>
<p><strong>数组元素访问</strong>：</p>
<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局数组：array[i]</span></span><br><span class="line">la $<span class="built_in">t0</span>, array              <span class="comment"># 数组基址</span></span><br><span class="line"><span class="keyword">sll </span>$<span class="built_in">t1</span>, $i_reg, <span class="number">2</span>         <span class="comment"># 索引 * 4</span></span><br><span class="line"><span class="keyword">addu </span>$<span class="built_in">t2</span>, $<span class="built_in">t0</span>, $<span class="built_in">t1</span>         <span class="comment"># 计算元素地址</span></span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">t3</span>, <span class="number">0</span>($<span class="built_in">t2</span>)             <span class="comment"># 加载元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 局部数组：local_array[const_idx]（常量索引优化）</span></span><br><span class="line"><span class="keyword">addiu </span>$<span class="built_in">t0</span>, $<span class="built_in">fp</span>, -<span class="number">200</span>       <span class="comment"># 基址 = $fp + offset + idx*4（直接计算）</span></span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">t1</span>, <span class="number">0</span>($<span class="built_in">t0</span>)             <span class="comment"># 加载元素</span></span><br></pre></td></tr></table></figure>
<h4 id="7-4-2-getelementptr-处理优化">7.4.2 getelementptr 处理优化</h4>
<p><strong>情况1：全局数组常量索引</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前（3条指令）：</span></span><br><span class="line">la $t0, array</span><br><span class="line">sll $t1, $idx, <span class="number">2</span></span><br><span class="line">addu $t2, $t0, $t1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后（2条指令）：</span></span><br><span class="line">la $t0, array</span><br><span class="line">addiu $t0, $t0, <span class="number">16</span>     <span class="comment">// offset = idx * 4 直接计算</span></span><br></pre></td></tr></table></figure>
<p><strong>情况2：局部数组常量索引</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前（4条指令）：</span></span><br><span class="line">addiu $t0, $fp, -<span class="number">200</span>   <span class="comment">// 数组基址</span></span><br><span class="line">sll $t1, $idx, <span class="number">2</span></span><br><span class="line">addu $t2, $t0, $t1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后（1条指令）：</span></span><br><span class="line">addiu $t0, $fp, -<span class="number">184</span>   <span class="comment">// 直接计算 -200 + idx*4</span></span><br></pre></td></tr></table></figure>
<p><strong>情况3：指针参数传递修正</strong></p>
<p>问题：getelementptr 结果是地址，但 <code>processLoad</code> / <code>processStore</code> 需要区分&quot;地址&quot;和&quot;值&quot;。</p>
<p>解决方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processLoad 中检查 pointerOrigin</span></span><br><span class="line"><span class="type">String</span> <span class="variable">ptrReg</span> <span class="operator">=</span> context.getRegister(varName);</span><br><span class="line"><span class="keyword">if</span> (ptrReg != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 寄存器存的是地址，从地址加载值</span></span><br><span class="line">    generateLw(resultReg, <span class="string">&quot;0&quot;</span>, ptrReg);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">offset</span> <span class="operator">=</span> context.getStackOffset(varName);</span><br><span class="line">    <span class="keyword">if</span> (context.getPointerOrigin(varName) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 栈上存的是地址，先加载地址再从地址加载值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">addrReg</span> <span class="operator">=</span> getTempRegister();</span><br><span class="line">        generateLw(addrReg, String.valueOf(offset), <span class="string">&quot;$fp&quot;</span>);</span><br><span class="line">        generateLw(resultReg, <span class="string">&quot;0&quot;</span>, addrReg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 栈上存的是值，直接加载</span></span><br><span class="line">        generateLw(resultReg, String.valueOf(offset), <span class="string">&quot;$fp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-5-计算指令处理">7.5 计算指令处理</h3>
<h3 id="7-5-函数调用处理：processCall-详解">7.5 函数调用处理：<code>processCall()</code> 详解</h3>
<p>函数调用是寄存器分配中最复杂的场景，涉及参数传递、寄存器保护、调用约定等多个环节。</p>
<h4 id="7-5-1-processCall-完整流程">7.5.1 <code>processCall()</code> 完整流程</h4>
<p><strong>输入</strong>：LLVM IR 指令 <code>%result = call i32 @func(i32 %a, i32 %b, ...)</code></p>
<p><strong>处理流程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1. 解析调用信息</span><br><span class="line">   ├─ 提取函数名、参数列表、返回类型</span><br><span class="line">   └─ 判断是否为 IO 函数（getint/putint/putch/putstr）</span><br><span class="line"></span><br><span class="line">2. IO 函数特殊处理</span><br><span class="line">   ├─ putint: 加载参数到 $a0，syscall 1</span><br><span class="line">   ├─ putch: 加载参数到 $a0，syscall 11</span><br><span class="line">   ├─ getint: syscall 5，返回值在 $v0</span><br><span class="line">   └─ putstr: 加载字符串地址到 $a0，syscall 4</span><br><span class="line"></span><br><span class="line">3. 用户函数调用</span><br><span class="line">   ├─ 阶段1：寄存器保护</span><br><span class="line">   │   └─ spillAllRegisters()  // Dirty Bit + Lazy Spill</span><br><span class="line">   │</span><br><span class="line">   ├─ 阶段2：参数传递</span><br><span class="line">   │   ├─ 前4个参数 → $a0-$a3（寄存器传递）</span><br><span class="line">   │   └─ 剩余参数 → 栈传递（$sp + offset）</span><br><span class="line">   │</span><br><span class="line">   ├─ 阶段3：执行调用</span><br><span class="line">   │   └─ jal func  // 跳转并保存返回地址到 $ra</span><br><span class="line">   │</span><br><span class="line">   └─ 阶段4：返回值处理</span><br><span class="line">       ├─ $v0 → allocateRegister(result)  // 返回值存入结果寄存器</span><br><span class="line">       └─ 标记为 Dirty（结果需要后续 Spill）</span><br><span class="line"></span><br><span class="line">4. Forwarding 缓存清除</span><br><span class="line">   └─ clearForwardingInfo()  // 函数调用后清除所有 Store-to-Load 缓存</span><br></pre></td></tr></table></figure>
<h4 id="7-5-2-参数传递详解">7.5.2 参数传递详解</h4>
<p><strong>参数传递约定</strong>（MIPS O32 calling convention）：</p>
<ul>
<li><strong>前4个参数</strong>：通过 <code>$a0-$a3</code> 传递</li>
<li><strong>第5+个参数</strong>：通过栈传递（相对 <code>$sp</code> 的正偏移）</li>
</ul>
<p><strong>实现代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析参数列表</span></span><br><span class="line">List&lt;String&gt; params = parseParams(paramsStr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数传递</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; params.size(); i++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> params.get(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// 前4个参数 → $a0-$a3</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">argReg</span> <span class="operator">=</span> <span class="string">&quot;$a&quot;</span> + i;</span><br><span class="line">        <span class="type">String</span> <span class="variable">srcReg</span> <span class="operator">=</span> loadOperand(param);  <span class="comment">// 加载参数值到临时寄存器</span></span><br><span class="line">        <span class="keyword">if</span> (!srcReg.equals(argReg)) &#123;</span><br><span class="line">            mipsCode.append(<span class="string">&quot;    move &quot;</span>).append(argReg).append(<span class="string">&quot;, &quot;</span>)</span><br><span class="line">                .append(srcReg).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 第5+个参数 → 栈</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">srcReg</span> <span class="operator">=</span> loadOperand(param);</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> (i - <span class="number">4</span>) * <span class="number">4</span>;  <span class="comment">// 栈上参数偏移</span></span><br><span class="line">        generateSw(srcReg, String.valueOf(offset), <span class="string">&quot;$sp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特殊情况：指针参数修正</strong></p>
<p>如果参数是 <code>getelementptr</code> 的结果（地址），需传递地址而非值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (context.getPointerOrigin(param) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 参数是地址，从栈中加载地址（而非从地址加载值）</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">off</span> <span class="operator">=</span> context.getStackOffset(param);</span><br><span class="line">    <span class="keyword">if</span> (off != <span class="literal">null</span>) &#123;</span><br><span class="line">        generateLw(srcReg, String.valueOf(off), <span class="string">&quot;$fp&quot;</span>);  <span class="comment">// 直接加载地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-5-3-寄存器保护策略">7.5.3 寄存器保护策略</h4>
<p><strong>保护时机</strong>：在参数传递前调用 <code>spillAllRegisters()</code>。</p>
<p><strong>保护对象</strong>：</p>
<ul>
<li>仅保护 <strong>Dirty</strong> 变量（Dirty Bit 过滤）</li>
<li>Clean 变量（从栈加载且未修改）直接丢弃</li>
<li>减少 <strong>95%</strong> 的不必要 <code>sw</code> 指令</li>
</ul>
<p><strong>实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用前保存寄存器</span></span><br><span class="line">spillAllRegisters();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除寄存器映射（调用后寄存器状态不确定）</span></span><br><span class="line">context.clearAllRegisterMappings();</span><br><span class="line">context.resetTempRegs();</span><br></pre></td></tr></table></figure>
<p><strong>为何清除映射？</strong></p>
<ul>
<li>被调用函数可能修改 <code>$8-$27</code> 的值（临时寄存器）</li>
<li>调用返回后，寄存器内容不可信，必须从栈重新加载</li>
</ul>
<h4 id="7-5-4-IO-函数优化">7.5.4 IO 函数优化</h4>
<p><strong>IO 函数特征</strong>：</p>
<ul>
<li>函数名：<code>getint</code> / <code>putint</code> / <code>putch</code> / <code>putstr</code></li>
<li>无需保存寄存器（系统调用不破坏 <code>$8-$27</code>）</li>
<li>直接使用 MIPS syscall</li>
</ul>
<p><strong>实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (funcName.equals(<span class="string">&quot;putint&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// putint(x) → syscall 1</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">srcReg</span> <span class="operator">=</span> loadOperand(params.get(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (!srcReg.equals(<span class="string">&quot;$a0&quot;</span>)) &#123;</span><br><span class="line">        mipsCode.append(<span class="string">&quot;    move $a0, &quot;</span>).append(srcReg).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mipsCode.append(<span class="string">&quot;    li $v0, 1\n&quot;</span>);</span><br><span class="line">    mipsCode.append(<span class="string">&quot;    syscall\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (funcName.equals(<span class="string">&quot;getint&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// getint() → syscall 5</span></span><br><span class="line">    mipsCode.append(<span class="string">&quot;    li $v0, 5\n&quot;</span>);</span><br><span class="line">    mipsCode.append(<span class="string">&quot;    syscall\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回值处理</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; !result.isEmpty()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resultReg</span> <span class="operator">=</span> allocateRegister(result);</span><br><span class="line">        <span class="keyword">if</span> (!resultReg.equals(<span class="string">&quot;$v0&quot;</span>)) &#123;</span><br><span class="line">            mipsCode.append(<span class="string">&quot;    move &quot;</span>).append(resultReg).append(<span class="string">&quot;, $v0\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (funcName.equals(<span class="string">&quot;putstr&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// putstr(str) → syscall 4</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">strName</span> <span class="operator">=</span> params.get(<span class="number">0</span>);</span><br><span class="line">    mipsCode.append(<span class="string">&quot;    la $a0, &quot;</span>).append(strName).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    mipsCode.append(<span class="string">&quot;    li $v0, 4\n&quot;</span>);</span><br><span class="line">    mipsCode.append(<span class="string">&quot;    syscall\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化效果</strong>：</p>
<ul>
<li>IO 函数无需 <code>spillAllRegisters()</code>，减少大量 <code>sw</code> 指令</li>
<li>直接使用 syscall，避免 <code>jal</code> 跳转开销</li>
</ul>
<h4 id="7-5-5-返回值处理">7.5.5 返回值处理</h4>
<p><strong>返回值约定</strong>：函数返回值存放在 <code>$v0</code>。</p>
<p><strong>处理流程</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用后获取返回值</span></span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; !result.isEmpty()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">resultReg</span> <span class="operator">=</span> allocateRegister(result);  <span class="comment">// 分配结果寄存器</span></span><br><span class="line">    <span class="keyword">if</span> (!resultReg.equals(<span class="string">&quot;$v0&quot;</span>)) &#123;</span><br><span class="line">        mipsCode.append(<span class="string">&quot;    move &quot;</span>).append(resultReg).append(<span class="string">&quot;, $v0\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dirtyVars.add(result);  <span class="comment">// 标记为 Dirty（结果尚未写回栈）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>allocateRegister(result)</code> 可能复用寄存器（触发 Spill）</li>
<li>新结果自动标记为 Dirty，确保后续会写回栈</li>
</ul>
<h4 id="7-5-6-Forwarding-缓存清除">7.5.6 Forwarding 缓存清除</h4>
<p><strong>原因</strong>：函数调用可能修改内存（例如修改全局变量、数组），导致旧的 Store-to-Load 缓存失效。</p>
<p><strong>实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用后清除所有 forwarding 信息</span></span><br><span class="line">clearForwardingInfo();</span><br></pre></td></tr></table></figure>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用前</span></span><br><span class="line">sw $<span class="number">8</span>, <span class="number">0</span>($fp)       <span class="comment">// 记录：0@$fp → $8</span></span><br><span class="line">lw $<span class="number">9</span>, <span class="number">0</span>($fp)       <span class="comment">// 优化为：move $9, $8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果中间有 call</span></span><br><span class="line">call func           <span class="comment">// func 可能修改栈</span></span><br><span class="line">lw $<span class="number">9</span>, <span class="number">0</span>($fp)       <span class="comment">// 必须重新 lw（缓存失效）</span></span><br></pre></td></tr></table></figure>
<h3 id="7-6-跳转分支指令处理">7.6 跳转分支指令处理</h3>
<h4 id="7-6-1-基本块管理">7.6.1 基本块管理</h4>
<p><strong>进入新基本块时</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (line.endsWith(<span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">    spillAllRegisters();           <span class="comment">// Spill 所有 Dirty 变量</span></span><br><span class="line">    clearForwardingInfo();         <span class="comment">// 清除 Store-to-Load 缓存</span></span><br><span class="line">    mipsCode.append(label).append(<span class="string">&quot;:\n&quot;</span>);</span><br><span class="line">    context.clearAllRegisterMappings();  <span class="comment">// 清除寄存器映射</span></span><br><span class="line">    context.resetTempRegs();       <span class="comment">// 重置临时寄存器标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>原因</strong>：新基本块可能有多个前驱，寄存器状态不确定，必须从栈重新加载。</p>
<h4 id="7-6-2-条件分支">7.6.2 条件分支</h4>
<p><strong>无条件跳转</strong>：</p>
<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">br </span>label %target</span><br><span class="line">=&gt;</span><br><span class="line">    spillAllRegisters()      <span class="comment"># Spill 前保存活跃变量</span></span><br><span class="line">    <span class="keyword">j </span>target                 <span class="comment"># 跳转</span></span><br></pre></td></tr></table></figure>
<h3 id="7-7-指令解析健壮性（避免命名碰撞）">7.7 指令解析健壮性（避免命名碰撞）</h3>
<p><strong>问题场景</strong>：后端若用 <code>line.contains(&quot;store&quot;)</code> / <code>line.contains(&quot;call&quot;)</code> 这类子串匹配来分派指令，会在指令名或寄存器名包含关键字时误判，例如 <code>@compute_and_store</code> 被当作 <code>store</code> 指令，导致调用不生成 <code>jal</code>。</p>
<p><strong>解决方案</strong>：统一使用 <code>extractOpcode()</code>：</p>
<pre><code>1) 用正则剥离可选前缀 `%tmp = `，再取首个 token 作为 opcode。
2) 预扫描（栈大小估计）和正式分派都复用该函数，保证一致。
</code></pre>
<p>核心代码：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">extractOpcode</span><span class="params">(String line)</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> line.trim();</span><br><span class="line">  <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^%[A-Za-z0-9_.]+\\s*=\\s*(.*)$&quot;</span>).matcher(body);</span><br><span class="line">  <span class="keyword">if</span> (m.find()) &#123;</span><br><span class="line">    body = m.group(<span class="number">1</span>).trim();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> <span class="variable">sp</span> <span class="operator">=</span> body.indexOf(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> sp == -<span class="number">1</span> ? body : body.substring(<span class="number">0</span>, sp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实践提示：凡是“识别是否为某指令”或“统计指令类型”的地方，都应依赖 opcode 而非字符串包含匹配。</p>
</blockquote>
<p><strong>条件跳转</strong>：</p>
<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">br </span>i1 %cond, label %true, label %false</span><br><span class="line">=&gt;</span><br><span class="line">    <span class="keyword">move </span>$<span class="built_in">t0</span>, %cond_reg      <span class="comment"># 复制条件到独立寄存器</span></span><br><span class="line">    spillAllRegisters()      <span class="comment"># Spill 前保存活跃变量</span></span><br><span class="line">    <span class="keyword">bnez </span>$<span class="built_in">t0</span>, true           <span class="comment"># 非零跳转</span></span><br><span class="line">    <span class="keyword">j </span>false                  <span class="comment"># 零跳转</span></span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong>：</p>
<ul>
<li>使用独立寄存器 <code>$t0</code> 保存条件，防止 <code>spillAllRegisters</code> 覆盖</li>
<li>分支前必须 Spill，确保目标块能正确加载变量</li>
</ul>
<h4 id="7-6-3-循环优化">7.6.3 循环优化</h4>
<p><strong>for 循环结构</strong>：</p>
<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">for_cond:</span></span><br><span class="line">    <span class="comment"># 条件检查</span></span><br><span class="line">    <span class="keyword">bnez </span>$cond, for_body</span><br><span class="line">    <span class="keyword">j </span>for_end</span><br><span class="line"><span class="symbol">for_body:</span></span><br><span class="line">    <span class="comment"># 循环体</span></span><br><span class="line">    <span class="keyword">j </span>for_post</span><br><span class="line"><span class="symbol">for_post:</span></span><br><span class="line">    <span class="comment"># 后置语句（i++）</span></span><br><span class="line">    <span class="keyword">j </span>for_cond</span><br><span class="line"><span class="symbol">for_end:</span></span><br></pre></td></tr></table></figure>
<p><strong>优化点</strong>：</p>
<ul>
<li>循环变量尽量保持在寄存器中（减少 <code>lw</code>/<code>sw</code>）</li>
<li><code>for_post</code> 块内的自增操作直接用 <code>addiu</code></li>
</ul>
<h3 id="7-7-函数序言与尾声">7.7 函数序言与尾声</h3>
<h4 id="7-7-1-函数序言（Prologue）">7.7.1 函数序言（Prologue）</h4>
<p><strong>职责</strong>：初始化函数栈帧，保存调用上下文，准备参数访问。</p>
<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">func:</span></span><br><span class="line">    <span class="comment"># 1. 分配栈空间</span></span><br><span class="line">    <span class="keyword">addiu </span>$<span class="built_in">sp</span>, $<span class="built_in">sp</span>, -stackSize</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 保存 $ra 和 $fp（调用者上下文）</span></span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">ra</span>, (stackSize<span class="number">-4</span>)($<span class="built_in">sp</span>)</span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">fp</span>, (stackSize<span class="number">-8</span>)($<span class="built_in">sp</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 设置新的 $fp（栈帧基址）</span></span><br><span class="line">    <span class="keyword">move </span>$<span class="built_in">fp</span>, $<span class="built_in">sp</span></span><br><span class="line">    <span class="keyword">addiu </span>$<span class="built_in">fp</span>, $<span class="built_in">fp</span>, stackSize</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. 保存参数到栈（前4个参数通过 $a0-$a3 传递）</span></span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">a0</span>, <span class="number">4</span>($<span class="built_in">fp</span>)       <span class="comment"># 第1个参数</span></span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">a1</span>, <span class="number">8</span>($<span class="built_in">fp</span>)       <span class="comment"># 第2个参数</span></span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">a2</span>, <span class="number">12</span>($<span class="built_in">fp</span>)      <span class="comment"># 第3个参数</span></span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">a3</span>, <span class="number">16</span>($<span class="built_in">fp</span>)      <span class="comment"># 第4个参数</span></span><br></pre></td></tr></table></figure>
<p><strong>栈帧布局</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">高地址</span><br><span class="line">+----------------+</span><br><span class="line">| 参数5+         | ← 调用者栈（如果参数 &gt; 4）</span><br><span class="line">+----------------+</span><br><span class="line">| $a3 (参数4)    | $fp + 16</span><br><span class="line">+----------------+</span><br><span class="line">| $a2 (参数3)    | $fp + 12</span><br><span class="line">+----------------+</span><br><span class="line">| $a1 (参数2)    | $fp + 8</span><br><span class="line">+----------------+</span><br><span class="line">| $a0 (参数1)    | $fp + 4</span><br><span class="line">+----------------+</span><br><span class="line">| (栈帧起点)     | ← $fp</span><br><span class="line">+----------------+</span><br><span class="line">| $ra            | $fp - 4</span><br><span class="line">+----------------+</span><br><span class="line">| $fp (旧)       | $fp - 8</span><br><span class="line">+----------------+</span><br><span class="line">| 局部变量       | $fp - 12, $fp - 16, ...</span><br><span class="line">+----------------+</span><br><span class="line">| (栈帧终点)     | ← $sp</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure>
<h4 id="7-7-2-函数尾声（Epilogue）">7.7.2 函数尾声（Epilogue）</h4>
<p><strong>职责</strong>：恢复调用者上下文，释放栈帧，返回调用点。</p>
<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 恢复 $ra 和 $fp</span></span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">ra</span>, -<span class="number">4</span>($<span class="built_in">fp</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">fp</span>, -<span class="number">8</span>($<span class="built_in">fp</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 恢复栈指针</span></span><br><span class="line"><span class="keyword">addiu </span>$<span class="built_in">sp</span>, $<span class="built_in">sp</span>, stackSize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 返回</span></span><br><span class="line"><span class="keyword">jr </span>$<span class="built_in">ra</span></span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>$ra</code> 保存返回地址，必须在 <code>jr</code> 前恢复</li>
<li><code>$fp</code> 必须在 <code>$sp</code> 恢复前先恢复（因为 <code>$fp</code> 是栈帧基址）</li>
<li>栈帧大小在编译时确定（见 7.2 节）</li>
</ul>
<h3 id="7-8-设计亮点">7.8 设计亮点</h3>
<h4 id="7-8-1-核心优化策略">7.8.1 核心优化策略</h4>
<table>
<thead>
<tr>
<th>优化技术</th>
<th>实现方式</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Dirty Bit 机制</strong></td>
<td>区分 Clean/Dirty 变量，Spill 时仅保存 Dirty</td>
<td>减少 95% 的函数调用寄存器保存</td>
</tr>
<tr>
<td><strong>引用计数分配</strong></td>
<td>优先分配引用计数小的寄存器，减少 Spill</td>
<td>减少 10-20% 的 Spill 操作</td>
</tr>
<tr>
<td><strong>Store-to-Load Forwarding</strong></td>
<td><code>sw</code> 后立即 <code>lw</code> 改为 <code>move</code></td>
<td>减少 5-10% 的 <code>lw</code> 指令</td>
</tr>
<tr>
<td><strong>Copy Propagation</strong></td>
<td>消除 <code>la</code>/<code>li</code> 后的冗余 <code>move</code></td>
<td>减少 15-25% 的 <code>move</code> 指令</td>
</tr>
<tr>
<td><strong>立即数指令</strong></td>
<td>使用 <code>addiu</code>/<code>slti</code> 替代 <code>li</code> + <code>add</code>/<code>slt</code></td>
<td>减少 15-20% 的 <code>li</code> 指令</td>
</tr>
<tr>
<td><strong>常量索引优化</strong></td>
<td>数组访问时直接计算偏移，避免 <code>sll</code>+<code>addu</code></td>
<td>减少 30-40% 的数组访问指令</td>
</tr>
<tr>
<td><strong>IO 函数快速路径</strong></td>
<td>IO 函数跳过寄存器保存/恢复</td>
<td>减少 100% 的 IO 调用开销</td>
</tr>
</tbody>
</table>
<h4 id="7-8-2-内存访问优化">7.8.2 内存访问优化</h4>
<p><strong>批量 Spill</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按栈偏移排序，利用缓存局部性</span></span><br><span class="line">toSpill.sort((a, b) -&gt; Integer.compare(a.offset, b.offset));</span><br><span class="line"><span class="keyword">for</span> (SpillInfo info : toSpill) &#123;</span><br><span class="line">    generateSw(info.reg, String.valueOf(info.offset), <span class="string">&quot;$fp&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getelementptr 多级优化</strong>：</p>
<ol>
<li>常量索引直接计算偏移（减少2-3条指令）</li>
<li>全局数组 <code>la</code> 直接到目标寄存器（减少1条 <code>move</code>）</li>
<li>指针参数区分&quot;地址&quot;和&quot;值&quot;（修复语义错误）</li>
</ol>
<h4 id="7-8-3-控制流优化">7.8.3 控制流优化</h4>
<p><strong>基本块边界优化</strong>：</p>
<ul>
<li>仅在必要时 Spill（Lazy Spill）</li>
<li>清除 forwarding 缓存防止跨块错误</li>
<li>重置寄存器映射确保语义正确</li>
</ul>
<p><strong>条件分支优化</strong>：</p>
<ul>
<li>独立寄存器保存条件，防止 Spill 覆盖</li>
<li>短路求值生成高效的跳转序列</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>作者: </span><span class="post-copyright-info"><a href="https://wrongization.site">wrongization</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>链接: </span><span class="post-copyright-info"><a href="https://wrongization.site/2026/01/10/compile.html">https://wrongization.site/2026/01/10/compile.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>转载注意: </span><span class="post-copyright-info">除非另有说明，否则本博客中的所有文章均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/%E7%BC%96%E8%AF%91/">编译</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/compile/compile.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2026/01/10/db.html" title="BUAA 2025数据库大作业"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/db/db.webp" onerror="onerror=null;src='/img/404.webp'" alt="cover of next post"><div class="pagination-info"><div class="label">昨夜</div><div class="next_info">BUAA 2025数据库大作业</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关文章</span></div><div class="relatedPosts-list"><div><a href="/2025/08/20/java.html" title="Java多版本环境配置"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/java/java.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-20</div><div class="title">Java多版本环境配置</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo.webp" onerror="this.onerror=null;this.src='/img/gif404.gif'" alt="avatar"/></div><div class="author-info__name">wrongization</div><div class="author-info__description">wrongization的博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">类别</div><div class="length-num">30</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wrongization"><i class="fab fa-github"></i><span>My Github Page</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://space.bilibili.com/175003959" target="_blank" title="bilibili"><i class="fab fa-bilibili" style="color: #FF69B4;"></i></a><a class="social-icon" href="https://500px.com.cn/wrongization" target="_blank" title="500px"><i class="fab fa-500px" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2560668452@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #7D26CD;"></i></a><a class="social-icon" href="https://steamcommunity.com/id/wrongization" target="_blank" title="steam"><i class="fab fa-steam-square" style="color: #00008B;"></i></a><a class="social-icon" href="https://www.test-ipv6.com/index.html.zh_CN" target="_blank" title="ipv6测试"><i class="fas fa-spinner fa-pulse" style="color: #00EE00;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">可以先看软件配置系列，顶部菜单栏可选择不同子页面。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">BUAA 2025 编译器设计说明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%80%BB%E4%BD%93%E7%9B%AE%E6%A0%87"><span class="toc-text">1. 总体目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%B8%8E%E8%81%8C%E8%B4%A3"><span class="toc-text">2. 目录结构与职责</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1"><span class="toc-text">3. 词法分析设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">3.1 处理流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">3.2 关键数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%AD%A3%E5%88%99%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%8C%96%E5%88%A4%E6%96%AD"><span class="toc-text">3.3 正则与最小化判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-text">3.4 错误处理策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E8%AE%BE%E8%AE%A1%E4%BA%AE%E7%82%B9"><span class="toc-text">3.5 设计亮点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1"><span class="toc-text">4. 语法分析设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%96%B9%E6%B3%95%E8%AE%BA"><span class="toc-text">4.1 方法论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%96%87%E6%B3%95%EF%BC%88%E7%AE%80%E5%8C%96-BNF-%E6%91%98%E8%A6%81%EF%BC%89"><span class="toc-text">4.2 文法（简化 BNF 摘要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%85%B3%E9%94%AE%E6%B6%88%E9%99%A4%E4%BA%8C%E4%B9%89%E6%80%A7-%E5%B7%A6%E9%80%92%E5%BD%92%E7%AD%96%E7%95%A5"><span class="toc-text">4.3 关键消除二义性&#x2F;左递归策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E7%BB%93%E5%90%88%E6%A0%91%E9%87%8D%E6%9E%84%E6%8A%80%E5%B7%A7"><span class="toc-text">左结合树重构技巧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-FIRST-%E9%9B%86%E4%B8%8E%E5%8F%AF%E9%80%89-%E9%87%8D%E5%A4%8D%E9%83%A8%E5%88%86"><span class="toc-text">4.4 FIRST 集与可选&#x2F;重复部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="toc-text">4.5 错误检测与恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E8%AF%AD%E6%B3%95%E6%A0%91%E8%BE%93%E5%87%BA%E7%AD%96%E7%95%A5"><span class="toc-text">4.6 语法树输出策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E8%AE%BE%E8%AE%A1%E4%BA%AE%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-text">4.7 设计亮点总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-FIRST%E9%9B%86%E5%88%97%E8%A1%A8"><span class="toc-text">4.8 FIRST集列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1"><span class="toc-text">5. 语义分析设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF%E4%B8%8E%E8%81%8C%E8%B4%A3"><span class="toc-text">5.1 核心思路与职责</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%AC%A6%E5%8F%B7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9D%A1%E7%9B%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">5.2 符号模型与条目类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC%E7%BA%A6%E6%9D%9F"><span class="toc-text">5.3 作用域类型与返回值约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E4%B8%BB%E8%A6%81%E6%A3%80%E6%9F%A5%E7%82%B9%EF%BC%88%E4%B8%8E%E8%A7%A6%E5%8F%91%E4%BD%8D%E7%BD%AE%EF%BC%89"><span class="toc-text">5.4 主要检查点（与触发位置）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E7%AC%A6%E5%8F%B7%E8%A1%A8%E8%BE%93%E5%87%BA"><span class="toc-text">5.5 符号表输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6%E9%94%99%E8%AF%AF%E4%B8%8E%E6%97%A5%E5%BF%97"><span class="toc-text">5.6错误与日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E8%AE%BE%E8%AE%A1"><span class="toc-text">6. 中间代码生成设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF%E4%B8%8E%E6%9E%B6%E6%9E%84"><span class="toc-text">6.1 核心思路与架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6"><span class="toc-text">6.2 关键组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-ModuleBuilder%EF%BC%88%E5%85%A8%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%89"><span class="toc-text">6.2.1 ModuleBuilder（全局管理器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-FunctionContext%EF%BC%88%E5%87%BD%E6%95%B0%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%89"><span class="toc-text">6.2.2 FunctionContext（函数上下文）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-LLVMGenerator%EF%BC%88IR-%E7%94%9F%E6%88%90%E6%A0%B8%E5%BF%83%EF%BC%89"><span class="toc-text">6.2.3 LLVMGenerator（IR 生成核心）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E7%82%B9"><span class="toc-text">6.3 关键技术点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86"><span class="toc-text">6.3.1 变量与数组处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%A4%84%E7%90%86"><span class="toc-text">6.3.2 控制流处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-3-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-text">6.3.3 函数调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-4-printf-%E8%BD%AC%E6%8D%A2"><span class="toc-text">6.3.4 printf 转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%80%BC%E8%A1%A8%E7%A4%BA"><span class="toc-text">6.4 类型系统与值表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Value-%E6%8A%BD%E8%B1%A1"><span class="toc-text">Value 抽象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Addr-%E6%8A%BD%E8%B1%A1"><span class="toc-text">Addr 抽象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalVar"><span class="toc-text">LocalVar</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E8%AE%BE%E8%AE%A1%E4%BA%AE%E7%82%B9"><span class="toc-text">6.5 设计亮点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E4%BC%98%E5%8C%96%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1"><span class="toc-text">6.6 优化框架设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E8%AE%BE%E8%AE%A1"><span class="toc-text">7. 目标代码生成设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-text">7.1 总体架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%88%E5%B8%A7%E5%B8%83%E5%B1%80"><span class="toc-text">7.2 自定义栈帧布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="toc-text">栈帧结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E8%A6%81%E7%82%B9"><span class="toc-text">设计要点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97"><span class="toc-text">栈帧大小计算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%81%8D%EF%BC%9A%E6%B4%BB%E8%B7%83%E5%8F%98%E9%87%8F%E5%B3%B0%E5%80%BC%E5%88%86%E6%9E%90"><span class="toc-text">第一遍：活跃变量峰值分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%81%8D%EF%BC%9A%E7%BB%9F%E8%AE%A1%E6%A0%88%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-text">第二遍：统计栈使用情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97"><span class="toc-text">最终大小计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%AE%A1%E7%AE%97"><span class="toc-text">示例计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D%E4%B8%8E%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-text">7.3 寄存器分配与管理策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-%E5%AF%84%E5%AD%98%E5%99%A8%E8%B5%84%E6%BA%90%E6%A6%82%E8%A7%88"><span class="toc-text">7.3.1 寄存器资源概览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-%E5%BA%95%E5%B1%82%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D%EF%BC%9AnextTempReg"><span class="toc-text">7.3.2 底层寄存器分配：nextTempReg()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-%E4%B8%B4%E6%97%B6%E5%AF%84%E5%AD%98%E5%99%A8%E8%8E%B7%E5%8F%96%EF%BC%9AgetTempRegister"><span class="toc-text">7.3.3 临时寄存器获取：getTempRegister()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-4-%E5%8F%98%E9%87%8F%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D%EF%BC%9AallocateRegister-varName"><span class="toc-text">7.3.4 变量寄存器分配：allocateRegister(varName)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-5-%E6%93%8D%E4%BD%9C%E6%95%B0%E5%8A%A0%E8%BD%BD%EF%BC%9AloadOperand-operand"><span class="toc-text">7.3.5 操作数加载：loadOperand(operand)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-6-%E5%AF%84%E5%AD%98%E5%99%A8-Spill-%E7%AD%96%E7%95%A5%EF%BC%9AspillAllRegisters"><span class="toc-text">7.3.6 寄存器 Spill 策略：spillAllRegisters()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-7-%E5%9F%BA%E6%9C%AC%E5%9D%97%E8%BE%B9%E7%95%8C%E5%A4%84%E7%90%86"><span class="toc-text">7.3.7 基本块边界处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-8-%E9%81%BF%E5%BC%80%E6%8C%87%E5%AE%9A%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%88%86%E9%85%8D%EF%BC%9AgetTempRegisterAvoid-avoidReg"><span class="toc-text">7.3.8 避开指定寄存器的分配：getTempRegisterAvoid(avoidReg)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-9-%E5%BC%BA%E5%88%B6%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%9AreloadOperandFresh-operand-avoidReg"><span class="toc-text">7.3.9 强制重新加载操作数：reloadOperandFresh(operand, avoidReg)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E8%AE%BF%E9%97%AE"><span class="toc-text">7.4 内存分配与访问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-1-%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F"><span class="toc-text">7.4.1 变量访问模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-2-getelementptr-%E5%A4%84%E7%90%86%E4%BC%98%E5%8C%96"><span class="toc-text">7.4.2 getelementptr 处理优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E8%AE%A1%E7%AE%97%E6%8C%87%E4%BB%A4%E5%A4%84%E7%90%86"><span class="toc-text">7.5 计算指令处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A4%84%E7%90%86%EF%BC%9AprocessCall-%E8%AF%A6%E8%A7%A3"><span class="toc-text">7.5 函数调用处理：processCall() 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-1-processCall-%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B"><span class="toc-text">7.5.1 processCall() 完整流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-2-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E8%AF%A6%E8%A7%A3"><span class="toc-text">7.5.2 参数传递详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-3-%E5%AF%84%E5%AD%98%E5%99%A8%E4%BF%9D%E6%8A%A4%E7%AD%96%E7%95%A5"><span class="toc-text">7.5.3 寄存器保护策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-4-IO-%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96"><span class="toc-text">7.5.4 IO 函数优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-5-%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-text">7.5.5 返回值处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-6-Forwarding-%E7%BC%93%E5%AD%98%E6%B8%85%E9%99%A4"><span class="toc-text">7.5.6 Forwarding 缓存清除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-%E8%B7%B3%E8%BD%AC%E5%88%86%E6%94%AF%E6%8C%87%E4%BB%A4%E5%A4%84%E7%90%86"><span class="toc-text">7.6 跳转分支指令处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-1-%E5%9F%BA%E6%9C%AC%E5%9D%97%E7%AE%A1%E7%90%86"><span class="toc-text">7.6.1 基本块管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-2-%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF"><span class="toc-text">7.6.2 条件分支</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90%E5%81%A5%E5%A3%AE%E6%80%A7%EF%BC%88%E9%81%BF%E5%85%8D%E5%91%BD%E5%90%8D%E7%A2%B0%E6%92%9E%EF%BC%89"><span class="toc-text">7.7 指令解析健壮性（避免命名碰撞）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-3-%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96"><span class="toc-text">7.6.3 循环优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-%E5%87%BD%E6%95%B0%E5%BA%8F%E8%A8%80%E4%B8%8E%E5%B0%BE%E5%A3%B0"><span class="toc-text">7.7 函数序言与尾声</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-1-%E5%87%BD%E6%95%B0%E5%BA%8F%E8%A8%80%EF%BC%88Prologue%EF%BC%89"><span class="toc-text">7.7.1 函数序言（Prologue）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-2-%E5%87%BD%E6%95%B0%E5%B0%BE%E5%A3%B0%EF%BC%88Epilogue%EF%BC%89"><span class="toc-text">7.7.2 函数尾声（Epilogue）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-%E8%AE%BE%E8%AE%A1%E4%BA%AE%E7%82%B9"><span class="toc-text">7.8 设计亮点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8-1-%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-text">7.8.1 核心优化策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8-2-%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E4%BC%98%E5%8C%96"><span class="toc-text">7.8.2 内存访问优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8-3-%E6%8E%A7%E5%88%B6%E6%B5%81%E4%BC%98%E5%8C%96"><span class="toc-text">7.8.3 控制流优化</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>系列文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/10/compile.html" title="BUAA 2025编译实验"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/compile/compile.webp" onerror="this.onerror=null;this.src='/img/404.webp'" alt="BUAA 2025编译实验"></a><div class="content"><a class="title" href="/2026/01/10/compile.html" title="BUAA 2025编译实验">BUAA 2025编译实验</a><time datetime="2026-01-10T07:48:36.000Z" title="创建 2026-01-10 15:48:36">2026-01-10</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最近投稿</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/10/compile.html" title="BUAA 2025编译实验"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/compile/compile.webp" onerror="this.onerror=null;this.src='/img/404.webp'" alt="BUAA 2025编译实验"/></a><div class="content"><a class="title" href="/2026/01/10/compile.html" title="BUAA 2025编译实验">BUAA 2025编译实验</a><time datetime="2026-01-10T07:48:36.000Z" title="创建 2026-01-10 15:48:36">2026-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/10/db.html" title="BUAA 2025数据库大作业"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/db/db.webp" onerror="this.onerror=null;this.src='/img/404.webp'" alt="BUAA 2025数据库大作业"/></a><div class="content"><a class="title" href="/2026/01/10/db.html" title="BUAA 2025数据库大作业">BUAA 2025数据库大作业</a><time datetime="2026-01-10T07:32:36.000Z" title="创建 2026-01-10 15:32:36">2026-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/20/python.html" title="Python-CUDA-CuDNN-Pytorch-Jupyter配置合集"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/python/python.webp" onerror="this.onerror=null;this.src='/img/404.webp'" alt="Python-CUDA-CuDNN-Pytorch-Jupyter配置合集"/></a><div class="content"><a class="title" href="/2025/08/20/python.html" title="Python-CUDA-CuDNN-Pytorch-Jupyter配置合集">Python-CUDA-CuDNN-Pytorch-Jupyter配置合集</a><time datetime="2025-08-20T05:45:14.000Z" title="创建 2025-08-20 13:45:14">2025-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/20/java.html" title="Java多版本环境配置"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/java/java.webp" onerror="this.onerror=null;this.src='/img/404.webp'" alt="Java多版本环境配置"/></a><div class="content"><a class="title" href="/2025/08/20/java.html" title="Java多版本环境配置">Java多版本环境配置</a><time datetime="2025-08-20T03:45:14.000Z" title="创建 2025-08-20 11:45:14">2025-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/18/os-shell.html" title="BUAA-OS-shell"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/osshell/osshell.webp" onerror="this.onerror=null;this.src='/img/404.webp'" alt="BUAA-OS-shell"/></a><div class="content"><a class="title" href="/2025/06/18/os-shell.html" title="BUAA-OS-shell">BUAA-OS-shell</a><time datetime="2025-06-17T16:28:25.000Z" title="创建 2025-06-18 00:28:25">2025-06-18</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient( 0deg,#D15FEE,30%,#7D26CD 100%)"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2026 By wrongization</div><div class="footer_custom_text"><a href="https://icp.gov.moe/?keyword=20250929" target="_blank">萌ICP备20250929号</a> <span id="realtime_duration"></span> <p> <a style="margin-inline:5px"target="_blank" href="https://hexo.io/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"> </a> <a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"> </a> <a style="margin-inline:5px"target="_blank" href="https://github.com/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"> </a> <a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"> </a> <a style="margin-inline:5px"target="_blank" href="https://www.cloudflare-cn.com"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/DNS-Cloudflare-f6821f?style=flat&logo=cloudflare" title="本站采用Clouldflare DNS" alt="Clouldflare"> </a> <a style="margin-inline:5px"target="_blank" href="https://ipw.cn/ipv6webcheck/?site=wrongization.github.io"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Internet-IPV6-07c160?style=flat&logo=data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjI2NjE2MjI3NDgxIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjI0NjkiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PGRlZnM+PHN0eWxlIHR5cGU9InRleHQvY3NzIj48L3N0eWxlPjwvZGVmcz48cGF0aCBkPSJNNTEyIDY0YTQ0OCA0NDggMCAxIDAgMCA4OTZBNDQ4IDQ0OCAwIDAgMCA1MTIgNjR6IG0wIDgyMC4wMzJBMzcyLjAzMiAzNzIuMDMyIDAgMCAxIDUxMiAxMzkuOTY4YTM3Mi4wMzIgMzcyLjAzMiAwIDAgMSAwIDc0NC4wNjR6IiBmaWxsPSIjMDdjMTYwIiBwLWlkPSIyNDcwIj48L3BhdGg+PHBhdGggZD0iTTM4Mi4yMDggNzMxLjI2NFYzMjBIMzIwdjQxMS4yNjRoNjIuMjA4eiBtMTQ0LjU3NiAwVjU3MS4xMzZoMTA2LjU2Yzk4LjQ5NiAwIDE0OC4wMzItNDIuMDQ4IDE0OC4wMzItMTI2LjE0NEM3ODEuMzc2IDM2MS40NzIgNzMyLjQxNiAzMjAgNjM0LjQ5NiAzMjBINDY0djQxMS4yNjRoNjIuNzg0eiBtMTAyLjUyOC0yMTMuNjk2SDUyNi43ODR2LTE0NGgxMDIuNTI4YzMwLjUyOCAwIDUyLjk5MiA1Ljc2IDY3LjM5MiAxNy4yOCAxNC40IDEwLjM2OCAyMS44ODggMjguOCAyMS44ODggNTQuMTQ0IDAgMjUuMzQ0LTcuNDg4IDQzLjc3Ni0yMS4zMTIgNTUuMjk2LTE0LjQgMTEuNTItMzYuODY0IDE3LjI4LTY3Ljk2OCAxNy4yOHoiIGZpbGw9IiMwN2MxNjAiIHAtaWQ9IjI0NzEiPjwvcGF0aD48L3N2Zz4=" title="本站支持IPv6访问" alt="ipv6"> </a> <a style="margin-inline:5px"target="_blank" href="https://v6.51.la/land/3L1PzYyEGNZiFQyL"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Support-51.LA-1690ff?style=flat&logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAAzNJREFUWEe9V0tPFEEQ5j+BC8h7kaiJB72oUS/Gg3pRSYw3PRkvHky8EpC3LNGoG4yKxIgxRPEgvjBBWUIEI+oShekZdmd2y/qGGXeYbmZndnUr+fbVPVVfV39V3VvVOig+x0fMNL9XFPGRbLptUMxX8ct6x22i9oRVUSBm25DQkIE0fuAvFUV7wiRe/GpZBFoZLYPqsWL4JwQQPD68SUQ1HoSyCdT1adQ5YdC16QzV9mrKOUEoiwBWHLuh0cSCST9EnnbdFNQUcSvKIrCzX9DBOzppWbLt4uQG1TAh1dztUBaBag7WNeNEZ3u5bFFDvxZJkCUTaBwQtGdE0NJazglPZPHHUw+NSFoomUBNj6DLzzec0AVLfjJpB2cmbEWURKCZU9zMGZhZsZywBVvL5G1dQB+qZ/0oiUCMU3z2sUF5J6jfumYyocUYmUALA3s8njKdcLJ9+Z2j3awP6ETlw4vIBOr7BB1N6qRvH9826AM6UfnwIjIBpHbgfaH0trPXrA/oBHpR+XERiUAjC2vfqKAVTd79rE+PmHFm3LD1ovLlIhIBNJ6rLzKbETw2tWTR8Ac5K4/mTVsvQSUZmgBSCUezPwuNxzW04P23dDJ8uoBOoJf6gJIMTQDN5cITufEsr+VtxSM7OJT81v8uG1iSoQig9Or52J1clBtP95vNANjrTkVv+MZ6gW6gH5XvUATqegUdH9Mloa1z1zvkdD23O779LpOEbpAhle+iBLDvSP/oR1lkY9z3cR9wRYa6vzIlbxN0w/6VJVmUQAOv7gALLK1vTa7FX0/7Tj50vr0JQcvrcpmeZ/1gIV7fQFEC1T0aXX8ll970V4v3VT77oYduzx3BtaeLpq0j6Mk7P5AAUtbB16yFX3LpXXqmvv1AD4fv4pbkyxi7OHHf4Dvk1vmBBGIsPgSC5dgfkGfMpXM2MdX9D3qI8UqTc6ZdEZgPwBKzWd4ynuN5LpBAE+/psXu6fetFWwXOcakd4d8w5p3rBcbQmFCWmI+jGz5OPjDs8dAE4gw4q+W0IXUuIEzvPD9Uz2HlqktKURH+b/wlwC/On1OzovD8OdVSnIFVsKkkmMRq25BI/QEyZCI2oNn1NQAAAABJRU5ErkJggg==" title="本站采用51.LA统计" alt="51.LA"> </a> </p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="darkmode" type="button" title="打开/关闭夜间模式"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="隐藏/显示侧边栏"><i class="fas fa-arrows-alt-h"></i></button><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="go-up" type="button" title="返回顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"></div><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"3L1PzYyEGNZiFQyL",ck:"3L1PzYyEGNZiFQyL"})</script><script src="https://sdk.51.la/perf/js-sdk-perf.min.js" crossorigin="anonymous"></script><script> new LingQue.Monitor().init({id:"3L1Q2CzO5ktWU3Sd"});</script><script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.7/dayjs.min.js"></script><script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.7/plugin/duration.min.js"></script><script src="/scripts/realtime.js"></script><linkrel="stylesheet"href="http://aciano.top/redirect/?target=https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.6" zIndex="-1" count="60" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="ZTMY" data-fontsize="15px" data-random="false" async="async"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>